import asyncio
import uuid
import logging
import json
from typing import Dict, Any, List
from datetime import datetime, timedelta

from apps.backend.src.agents.base_agent import BaseAgent
from apps.backend.src.hsp.types import HSPTaskRequestPayload, HSPTaskResultPayload, HSPMessageEnvelope

class PlanningAgent(BaseAgent):
    """
    A specialized agent for task planning, scheduling, and project management.
    """
    def __init__(self, agent_id: str):
        capabilities = [
            {
                "capability_id": f"{agent_id}_task_planning_v1.0",
                "name": "task_planning",
                "description": "Creates detailed plans for complex tasks or projects.",
                "version": "1.0",
                "parameters": [
                    {"name": "goal", "type": "string", "required": True, "description": "The main goal or objective to plan for"},
                    {"name": "constraints", "type": "object", "required": False, "description": "Time, resource, or other constraints"},
                    {"name": "dependencies", "type": "array", "required": False, "description": "List of task dependencies"}
                ],
                "returns": {"type": "object", "description": "Detailed plan with tasks, timeline, and resources."}
            },
            {
                "capability_id": f"{agent_id}_schedule_optimization_v1.0",
                "name": "schedule_optimization",
                "description": "Optimizes task schedules based on priorities and constraints.",
                "version": "1.0",
                "parameters": [
                    {"name": "tasks", "type": "array", "required": True, "description": "List of tasks with durations and priorities"},
                    {"name": "resources", "type": "array", "required": False, "description": "Available resources with capacities"},
                    {"name": "deadline", "type": "string", "required": False, "description": "Project deadline in ISO format"}
                ],
                "returns": {"type": "object", "description": "Optimized schedule with task assignments and timeline."}
            },
            {
                "capability_id": f"{agent_id}_progress_tracking_v1.0",
                "name": "progress_tracking",
                "description": "Tracks and reports on project progress and identifies delays.",
                "version": "1.0",
                "parameters": [
                    {"name": "plan", "type": "object", "required": True, "description": "Original plan with tasks and timeline"},
                    {"name": "current_status", "type": "object", "required": True, "description": "Current status of tasks with completion percentages"}
                ],
                "returns": {"type": "object", "description": "Progress report with completion status and delay analysis."}
            }
        ]
        super().__init__(agent_id=agent_id, capabilities=capabilities)
        logging.info(f"[{self.agent_id}] PlanningAgent initialized with capabilities: {[cap['name'] for cap in capabilities]}")

    async def handle_task_request(self, task_payload: HSPTaskRequestPayload, sender_ai_id: str, envelope: HSPMessageEnvelope):
        request_id = task_payload.get("request_id")
        capability_id = task_payload.get("capability_id_filter", "")
        params = task_payload.get("parameters", {})

        logging.info(f"[{self.agent_id}] Handling task {request_id} for capability '{capability_id}'")

        try:
            if "task_planning" in capability_id:
                result = self._create_task_plan(params)
                result_payload = self._create_success_payload(request_id, result)
            elif "schedule_optimization" in capability_id:
                result = self._optimize_schedule(params)
                result_payload = self._create_success_payload(request_id, result)
            elif "progress_tracking" in capability_id:
                result = self._track_progress(params)
                result_payload = self._create_success_payload(request_id, result)
            else:
                result_payload = self._create_failure_payload(request_id, "CAPABILITY_NOT_SUPPORTED", f"Capability '{capability_id}' is not supported by this agent.")
        except Exception as e:
            logging.error(f"[{self.agent_id}] Error processing task {request_id}: {e}")
            result_payload = self._create_failure_payload(request_id, "EXECUTION_ERROR", str(e))

        if self.hsp_connector and task_payload.get("callback_address"):
            callback_topic = task_payload["callback_address"]
            await self.hsp_connector.send_task_result(result_payload, callback_topic)
            logging.info(f"[{self.agent_id}] Sent task result for {request_id} to {callback_topic}")

    def _create_task_plan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Creates a detailed task plan."""
        goal = params.get('goal', '')
        constraints = params.get('constraints', {})
        dependencies = params.get('dependencies', [])
        
        if not goal:
            raise ValueError("No goal provided for task planning")
        
        # In a real implementation, this would use advanced planning algorithms
        # For this example, we'll create a simple plan generator
        
        # Define common task types for different goals
        task_templates = {
            "software development": [
                {"name": "Requirements Analysis", "duration": 5, "resources": ["analyst"]},
                {"name": "System Design", "duration": 7, "resources": ["architect"]},
                {"name": "Implementation", "duration": 15, "resources": ["developer"]},
                {"name": "Testing", "duration": 8, "resources": ["tester"]},
                {"name": "Deployment", "duration": 3, "resources": ["devops"]}
            ],
            "marketing campaign": [
                {"name": "Market Research", "duration": 5, "resources": ["researcher"]},
                {"name": "Campaign Design", "duration": 7, "resources": ["designer"]},
                {"name": "Content Creation", "duration": 10, "resources": ["copywriter"]},
                {"name": "Media Buying", "duration": 3, "resources": ["media specialist"]},
                {"name": "Launch", "duration": 1, "resources": ["manager"]},
                {"name": "Performance Analysis", "duration": 5, "resources": ["analyst"]}
            ],
            "event planning": [
                {"name": "Venue Selection", "duration": 3, "resources": ["planner"]},
                {"name": "Vendor Coordination", "duration": 7, "resources": ["coordinator"]},
                {"name": "Marketing", "duration": 10, "resources": ["marketer"]},
                {"name": "Logistics", "duration": 5, "resources": ["logistics"]},
                {"name": "Event Execution", "duration": 1, "resources": ["manager"]},
                {"name": "Post-Event Analysis", "duration": 3, "resources": ["analyst"]}
            ]
        }
        
        # Match goal to template or create generic plan
        plan_type = "generic"
        if "software" in goal.lower() or "app" in goal.lower() or "application" in goal.lower():
            plan_type = "software development"
        elif "marketing" in goal.lower() or "campaign" in goal.lower():
            plan_type = "marketing campaign"
        elif "event" in goal.lower() or "conference" in goal.lower() or "party" in goal.lower():
            plan_type = "event planning"
        
        tasks = task_templates.get(plan_type, [
            {"name": "Task 1", "duration": 5, "resources": ["resource1"]},
            {"name": "Task 2", "duration": 3, "resources": ["resource2"]},
            {"name": "Task 3", "duration": 7, "resources": ["resource3"]},
            {"name": "Review", "duration": 2, "resources": ["manager"]},
            {"name": "Completion", "duration": 1, "resources": ["manager"]}
        ])
        
        # Apply constraints
        start_date = constraints.get('start_date', datetime.now().isoformat())
        deadline = constraints.get('deadline')
        
        # Create timeline
        try:
            start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
        except:
            start_dt = datetime.now()
        
        timeline = []
        current_date = start_dt
        for i, task in enumerate(tasks):
            task_start = current_date
            task_end = current_date + timedelta(days=task['duration'])
            
            # Handle dependencies
            depends_on = []
            if i > 0:
                depends_on = [tasks[i-1]['name']]
            
            timeline.append({
                "task_id": f"task_{i+1:03}",
                "name": task['name'],
                "start_date": task_start.isoformat(),
                "end_date": task_end.isoformat(),
                "duration_days": task['duration'],
                "resources": task['resources'],
                "depends_on": depends_on,
                "status": "pending"
            })
            
            current_date = task_end
        
        return {
            "plan_id": f"plan_{uuid.uuid4().hex[:8]}",
            "goal": goal,
            "plan_type": plan_type,
            "created_date": datetime.now().isoformat(),
            "start_date": start_date,
            "estimated_end_date": current_date.isoformat(),
            "deadline": deadline,
            "tasks": timeline,
            "total_duration_days": sum(task['duration'] for task in tasks),
            "critical_path_length_days": sum(task['duration'] for task in tasks)  # Simplified
        }

    def _optimize_schedule(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Optimizes a task schedule."""
        tasks = params.get('tasks', [])
        resources = params.get('resources', [])
        deadline = params.get('deadline')
        
        if not tasks:
            raise ValueError("No tasks provided for schedule optimization")
        
        # In a real implementation, this would use sophisticated scheduling algorithms
        # For this example, we'll implement a simple priority-based scheduler
        
        # Sort tasks by priority (assuming priority is a numeric value, higher is more important)
        sorted_tasks = sorted(tasks, key=lambda x: x.get('priority', 0), reverse=True)
        
        # Assign resources to tasks
        resource_assignments = {}
        for resource in resources:
            resource_assignments[resource.get('name', 'unnamed')] = {
                "capacity": resource.get('capacity', 1),
                "assigned_tasks": []
            }
        
        # Simple resource allocation
        for task in sorted_tasks:
            assigned_resource = None
            # Find first available resource
            for res_name, res_info in resource_assignments.items():
                if len(res_info['assigned_tasks']) < res_info['capacity']:
                    assigned_resource = res_name
                    break
            
            if assigned_resource:
                task['assigned_resource'] = assigned_resource
                resource_assignments[assigned_resource]['assigned_tasks'].append(task['name'])
            else:
                task['assigned_resource'] = "unassigned"
        
        # Create optimized timeline
        timeline = []
        current_time = datetime.now()
        
        for task in sorted_tasks:
            task_start = current_time
            duration = task.get('duration', 1)
            task_end = current_time + timedelta(days=duration)
            
            timeline.append({
                "task_name": task['name'],
                "start_time": task_start.isoformat(),
                "end_time": task_end.isoformat(),
                "duration_days": duration,
                "assigned_resource": task.get('assigned_resource', 'unassigned'),
                "priority": task.get('priority', 0)
            })
            
            current_time = task_end
        
        # Check if schedule meets deadline
        meets_deadline = True
        if deadline:
            try:
                deadline_dt = datetime.fromisoformat(deadline.replace('Z', '+00:00'))
                if current_time > deadline_dt:
                    meets_deadline = False
            except:
                pass  # Invalid deadline format
        
        return {
            "optimized_schedule": timeline,
            "total_duration_days": sum(t['duration_days'] for t in timeline),
            "meets_deadline": meets_deadline,
            "deadline": deadline,
            "resource_utilization": resource_assignments,
            "critical_path_length_days": sum(t['duration_days'] for t in timeline)  # Simplified
        }

    def _track_progress(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Tracks project progress."""
        plan = params.get('plan', {})
        current_status = params.get('current_status', {})
        
        if not plan or not current_status:
            raise ValueError("Plan and current status are required for progress tracking")
        
        # Extract tasks from plan
        plan_tasks = plan.get('tasks', [])
        status_tasks = current_status.get('tasks', {})
        
        # Analyze progress
        total_tasks = len(plan_tasks)
        completed_tasks = 0
        in_progress_tasks = 0
        not_started_tasks = 0
        delayed_tasks = 0
        
        task_details = []
        current_time = datetime.now()
        
        for task in plan_tasks:
            task_name = task.get('name')
            task_status = status_tasks.get(task_name, {}).get('status', 'not_started')
            completion_percentage = status_tasks.get(task_name, {}).get('completion', 0)
            
            # Determine if task is delayed
            delayed = False
            if task_status == 'in_progress':
                try:
                    end_date = datetime.fromisoformat(task.get('end_date', '').replace('Z', '+00:00'))
                    if current_time > end_date:
                        delayed = True
                        delayed_tasks += 1
                except:
                    pass
            
            # Update counters
            if task_status == 'completed':
                completed_tasks += 1
            elif task_status == 'in_progress':
                in_progress_tasks += 1
            else:
                not_started_tasks += 1
            
            task_details.append({
                "task_name": task_name,
                "status": task_status,
                "completion_percentage": completion_percentage,
                "delayed": delayed,
                "planned_end_date": task.get('end_date'),
                "assigned_resource": task.get('assigned_resource', 'unknown')
            })
        
        # Calculate overall progress
        overall_completion = 0
        if total_tasks > 0:
            # Weighted completion based on task durations
            total_duration = sum(task.get('duration_days', 1) for task in plan_tasks)
            weighted_completion = 0
            
            for task in plan_tasks:
                task_name = task.get('name')
                completion_percentage = status_tasks.get(task_name, {}).get('completion', 0)
                task_duration = task.get('duration_days', 1)
                weighted_completion += (completion_percentage / 100) * task_duration
            
            if total_duration > 0:
                overall_completion = (weighted_completion / total_duration) * 100
        
        # Determine project status
        if overall_completion >= 95:
            project_status = "completed"
        elif overall_completion >= 70:
            project_status = "on_track"
        elif delayed_tasks > 0:
            project_status = "delayed"
        else:
            project_status = "in_progress"
        
        return {
            "project_id": plan.get('plan_id', 'unknown'),
            "project_status": project_status,
            "overall_completion_percentage": round(overall_completion, 2),
            "total_tasks": total_tasks,
            "completed_tasks": completed_tasks,
            "in_progress_tasks": in_progress_tasks,
            "not_started_tasks": not_started_tasks,
            "delayed_tasks": delayed_tasks,
            "progress_details": task_details,
            "report_date": datetime.now().isoformat(),
            "estimated_completion_date": self._estimate_completion_date(plan, current_status)
        }

    def _estimate_completion_date(self, plan: Dict[str, Any], current_status: Dict[str, Any]) -> str:
        """Estimates project completion date based on current progress."""
        # Simplified estimation - in a real implementation, this would be more sophisticated
        plan_end_date = plan.get('estimated_end_date')
        if not plan_end_date:
            return datetime.now().isoformat()
        
        try:
            plan_end_dt = datetime.fromisoformat(plan_end_date.replace('Z', '+00:00'))
            # If we're behind schedule, add some buffer
            current_progress = current_status.get('overall_completion_percentage', 50)
            if current_progress < 50:
                # Add 20% more time if less than halfway
                buffer_days = (plan_end_dt - datetime.now()).days * 0.2
                plan_end_dt += timedelta(days=buffer_days)
            return plan_end_dt.isoformat()
        except:
            return datetime.now().isoformat()

    def _create_success_payload(self, request_id: str, result: Any) -> HSPTaskResultPayload:
        return HSPTaskResultPayload(
            request_id=request_id,
            status="success",
            payload=result
        )

    def _create_failure_payload(self, request_id: str, error_code: str, error_message: str) -> HSPTaskResultPayload:
        return HSPTaskResultPayload(
            request_id=request_id,
            status="failure",
            error_details={"error_code": error_code, "error_message": error_message}
        )


if __name__ == '__main__':
    async def main():
        agent_id = f"did:hsp:planning_agent_{uuid.uuid4().hex[:6]}"
        agent = PlanningAgent(agent_id=agent_id)
        await agent.start()

    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nPlanningAgent manually stopped.")