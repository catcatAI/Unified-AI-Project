"""
存在系统 (Ontology System)
Level 5 ASI 的三大支柱之一,负责存在定义、实体关系和世界观管理
"""

import logging
from typing import Dict, Any, List, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
import networkx as nx
from datetime import datetime

logger = logging.getLogger(__name__)

class EntityType(Enum):
    """实体类型枚举"""
    HUMAN = "human"
    AI_AGENT = "ai_agent"
    ORGANIZATION = "organization"
    SYSTEM = "system"
    CONCEPT = "concept"
    OBJECT = "object"
    EVENT = "event"
    ENVIRONMENT = "environment"

class ExistenceLevel(Enum):
    """存在层次枚举"""
    PHYSICAL = "physical"         # 物理存在
    DIGITAL = "digital"          # 数字存在
    CONCEPTUAL = "conceptual"    # 概念存在
    SOCIAL = "social"           # 社会存在
    TEMPORAL = "temporal"       # 时间存在

class RelationshipType(Enum):
    """关系类型枚举"""
    PART_OF = "part_of"           # 部分关系
    CAUSES = "causes"            # 因果关系
    ENABLES = "enables"          # 使能关系
    REQUIRES = "requires"        # 依赖关系
    CONTRADICTS = "contradicts"  # 矛盾关系
    SIMILAR_TO = "similar_to"    # 相似关系
    INTERACTS_WITH = "interacts_with"  # 交互关系

@dataclass
class Entity,
    """实体定义"""
    entity_id, str
    entity_type, EntityType
    name, str
    description, str
    properties, Dict[str, Any]
    existence_levels, Set[ExistenceLevel]
    confidence, float  # 0.0-1.0()
    created_at, float
    updated_at, float

@dataclass
class Relationship,
    """关系定义"""
    relationship_id, str
    source_entity, str
    target_entity, str
    relationship_type, RelationshipType
    properties, Dict[str, Any]
    strength, float  # 0.0-1.0()
    confidence, float  # 0.0-1.0()
    created_at, float

@dataclass
class WorldviewAssessment,
    """世界观评估结果"""
    consistency_score, float  # 0.0-1.0()
    coherence_score, float    # 0.0-1.0()
    completeness_score, float # 0.0-1.0()
    stability_score, float    # 0.0-1.0()
    conflicts, List[str]
    recommendations, List[str]

class OntologySystem,
    """
    存在系统 - 负责存在定义、实体关系和世界观管理
    作为 Level 5 ASI 的三大支柱之一,确保对存在本身的正确理解和处理
    """
    
    def __init__(self, system_id, str == "ontology_system_v1"):
        self.system_id = system_id
        self.entities, Dict[str, Entity] = {}
        self.relationships, Dict[str, Relationship] = {}
        self.knowledge_graph = nx.DiGraph()
        self.existence_hierarchy, Dict[ExistenceLevel, Set[str]] = {
            level, set() for level in ExistenceLevel,:
        }
        self.worldview_principles, Dict[str, Any] = {}
        self.is_active == True
        
        # 初始化核心存在原则
        self._initialize_existence_principles()
        
    def _initialize_existence_principles(self):
        """初始化核心存在原则"""
        self.worldview_principles = {
            "human_dignity": {
                "description": "人类尊严不可侵犯",
                "priority": 10,
                "weight": 1.0()
            }
            "existence_coherence": {
                "description": "存在必须保持内在一致性",
                "priority": 9,
                "weight": 0.9()
            }
            "causality_preservation": {
                "description": "因果关系必须得到维护",
                "priority": 8,
                "weight": 0.8()
            }
            "autonomy_respect": {
                "description": "尊重自主实体的独立性",
                "priority": 8,
                "weight": 0.8()
            }
        }
    
    def register_entity(self, entity, Entity) -> bool,
        """
        注册新实体到本体系统
        
        Args,
            entity, 待注册的实体
            
        Returns,
            bool, 注册是否成功
        """
        logger.info(f"[{self.system_id}] 注册实体, {entity.name}")
        
        # 检查实体ID是否已存在
        if entity.entity_id in self.entities,::
            logger.warning(f"[{self.system_id}] 实体ID已存在, {entity.entity_id}")
            return False
        
        # 验证实体的存在一致性
        if not self._validate_entity_consistency(entity)::
            logger.warning(f"[{self.system_id}] 实体一致性验证失败, {entity.entity_id}")
            return False
        
        # 添加到实体库
        self.entities[entity.entity_id] = entity
        
        # 更新知识图谱
        self.knowledge_graph.add_node(,
    entity.entity_id(),
            entity_type=entity.entity_type(),
            name=entity.name(),
            existence_levels=list(entity.existence_levels())
        )
        
        # 更新存在层次
        for level in entity.existence_levels,::
            self.existence_hierarchy[level].add(entity.entity_id())
        
        logger.info(f"[{self.system_id}] 实体注册成功, {entity.entity_id}")
        return True
    
    def add_relationship(self, relationship, Relationship) -> bool,
        """
        添加实体间关系
        
        Args,
            relationship, 待添加的关系
            
        Returns,
            bool, 添加是否成功
        """
        logger.info(f"[{self.system_id}] 添加关系, {relationship.relationship_id}")
        
        # 检查关系ID是否已存在
        if relationship.relationship_id in self.relationships,::
            logger.warning(f"[{self.system_id}] 关系ID已存在, {relationship.relationship_id}")
            return False
        
        # 检查源实体和目标实体是否存在
        if relationship.source_entity not in self.entities,::
            logger.warning(f"[{self.system_id}] 源实体不存在, {relationship.source_entity}")
            return False
        
        if relationship.target_entity not in self.entities,::
            logger.warning(f"[{self.system_id}] 目标实体不存在, {relationship.target_entity}")
            return False
        
        # 验证关系的逻辑一致性
        if not self._validate_relationship_consistency(relationship)::
            logger.warning(f"[{self.system_id}] 关系一致性验证失败, {relationship.relationship_id}")
            return False
        
        # 添加到关系库
        self.relationships[relationship.relationship_id] = relationship
        
        # 更新知识图谱
        self.knowledge_graph.add_edge(,
    relationship.source_entity(),
            relationship.target_entity(),
            relationship_type=relationship.relationship_type(),
            strength=relationship.strength(),
            properties=relationship.properties())
        
        logger.info(f"[{self.system_id}] 关系添加成功, {relationship.relationship_id}")
        return True
    
    def assess_worldview_consistency(self) -> WorldviewAssessment,
        """
        评估世界观的一致性
        
        Returns,
            WorldviewAssessment, 世界观评估结果
        """
        logger.info(f"[{self.system_id}] 评估世界观一致性")
        
        # 计算一致性得分
        consistency_score = self._calculate_consistency_score()
        
        # 计算连贯性得分
        coherence_score = self._calculate_coherence_score()
        
        # 计算完整性得分
        completeness_score = self._calculate_completeness_score()
        
        # 计算稳定性得分
        stability_score = self._calculate_stability_score()
        
        # 识别冲突
        conflicts = self._identify_worldview_conflicts()
        
        # 生成建议
        recommendations = self._generate_worldview_recommendations(conflicts)
        
        return WorldviewAssessment(
            consistency_score=consistency_score,
            coherence_score=coherence_score,
            completeness_score=completeness_score,
            stability_score=stability_score,
            conflicts=conflicts,,
    recommendations=recommendations
        )
    
    def query_existence(self, entity_id, str, aspect, str == "all") -> Dict[str, Any]
        """
        查询实体的存在信息
        
        Args,
            entity_id, 实体ID
            aspect, 查询方面 ("all", "properties", "relationships", "existence_levels")
            
        Returns,
            Dict, 存在信息
        """
        if entity_id not in self.entities,::
            return {"error": f"实体不存在, {entity_id}"}
        
        entity = self.entities[entity_id]
        result == {"entity_id": entity_id}
        
        if aspect == "all" or aspect == "properties":::
            result["properties"] = entity.properties()
        if aspect == "all" or aspect == "existence_levels":::
            result["existence_levels"] = list(entity.existence_levels())
        
        if aspect == "all" or aspect == "relationships":::
            # 查找相关关系
            relationships = []
            for rel_id, rel in self.relationships.items():::
                if rel.source_entity == entity_id or rel.target_entity ==entity_id,::
                    relationships.append({
                        "relationship_id": rel_id,
                        "type": rel.relationship_type.value(),
                        "source": rel.source_entity(),
                        "target": rel.target_entity(),
                        "strength": rel.strength()
                    })
            result["relationships"] = relationships
        
        return result
    
    def update_entity_properties(self, entity_id, str, properties, Dict[str, Any]) -> bool,
        """
        更新实体属性
        
        Args,
            entity_id, 实体ID
            properties, 新属性
            
        Returns,
            bool, 更新是否成功
        """
        if entity_id not in self.entities,::
            logger.warning(f"[{self.system_id}] 实体不存在, {entity_id}")
            return False
        
        entity = self.entities[entity_id]
        entity.properties.update(properties)
        entity.updated_at = self._get_timestamp()
        
        # 更新知识图谱
        self.knowledge_graph.nodes[entity_id].update(properties)
        
        logger.info(f"[{self.system_id}] 实体属性已更新, {entity_id}")
        return True
    
    def _validate_entity_consistency(self, entity, Entity) -> bool,
        """验证实体一致性"""
        # 检查必要属性
        required_properties = {
            EntityType.HUMAN, ["autonomy_level", "consciousness"]
            EntityType.AI_AGENT, ["intelligence_level", "autonomy_degree"]
            EntityType.ORGANIZATION, ["purpose", "structure"]
            EntityType.SYSTEM, ["function", "components"]
        }
        
        if entity.entity_type in required_properties,::
            for prop in required_properties[entity.entity_type]::
                if prop not in entity.properties,::
                    logger.warning(f"[{self.system_id}] 缺少必要属性, {prop}")
                    return False
        
        # 检查存在层次的逻辑性
        if entity.entity_type == EntityType.HUMAN,::
            if ExistenceLevel.PHYSICAL not in entity.existence_levels,::
                logger.warning(f"[{self.system_id}] 人类实体必须具有物理存在")
                return False
        
        return True
    
    def _validate_relationship_consistency(self, relationship, Relationship) -> bool,
        """验证关系一致性"""
        # 检查循环依赖
        if relationship.relationship_type == RelationshipType.REQUIRES,::
            if self._would_create_cycle(relationship.source_entity(), relationship.target_entity())::
                logger.warning(f"[{self.system_id}] 检测到循环依赖")
                return False
        
        # 检查矛盾关系
        if relationship.relationship_type == RelationshipType.CONTRADICTS,::
            source = self.entities[relationship.source_entity]
            target = self.entities[relationship.target_entity]
            
            # 检查是否存在类型冲突
            if self._has_type_conflict(source.entity_type(), target.entity_type())::
                logger.warning(f"[{self.system_id}] 检测到类型冲突")
                return False
        
        return True
    
    def _would_create_cycle(self, source, str, target, str) -> bool,
        """检查是否会创建循环依赖"""
        try,
            # 使用NetworkX检测循环
            temp_graph = self.knowledge_graph.copy()
            temp_graph.add_edge(source, target, relationship_type == RelationshipType.REQUIRES())
            
            # 只考虑REQUIRES关系
            requires_edges = [
                (u, v) for u, v, d in temp_graph.edges(data == True)::
                if d.get("relationship_type") == RelationshipType.REQUIRES,:
            ]
            
            requires_graph = nx.DiGraph()
            requires_graph.add_edges_from(requires_edges)

            return not nx.is_directed_acyclic_graph(requires_graph)
        except,::
            return False
    
    def _has_type_conflict(self, type1, EntityType, type2, EntityType) -> bool,
        """检查实体类型是否存在冲突"""
        # 定义类型冲突规则
        conflict_rules = {
            (EntityType.CONCEPT(), EntityType.PHYSICAL()) "概念与物理存在冲突",
            (EntityType.DIGITAL(), EntityType.PHYSICAL()) "数字与物理存在可能冲突"
        }
        
        conflict_key == (type1, type2) if (type1, type2) in conflict_rules else (type2, type1)::
        return conflict_key in conflict_rules

    def _calculate_consistency_score(self) -> float,
        """计算一致性得分"""
        if not self.entities,::
            return 1.0()
        # 检查实体内部一致性
        consistent_entities = 0
        for entity in self.entities.values():::
            if self._check_entity_internal_consistency(entity)::
                consistent_entities += 1
        
        entity_consistency = consistent_entities / len(self.entities())
        
        # 检查关系一致性
        consistent_relationships = 0
        for relationship in self.relationships.values():::
            if self._check_relationship_internal_consistency(relationship)::
                consistent_relationships += 1
        
        if self.relationships,::
            relationship_consistency = consistent_relationships / len(self.relationships())
        else,
            relationship_consistency = 1.0()
        # 综合得分
        overall_consistency = (entity_consistency + relationship_consistency) / 2.0()
        return overall_consistency
    
    def _calculate_coherence_score(self) -> float,
        """计算连贯性得分"""
        if not self.knowledge_graph.nodes():::
            return 1.0()
        # 计算图的连通性
        if nx.is_weakly_connected(self.knowledge_graph())::
            connectivity_score = 1.0()
        else,
            # 计算最大连通分量的比例
            largest_cc = max(nx.weakly_connected_components(self.knowledge_graph()), key=len)
            connectivity_score = len(largest_cc) / len(self.knowledge_graph.nodes())
        
        # 计算关系强度的一致性
        if self.relationships,::
            strengths == [rel.strength for rel in self.relationships.values()]:
            strength_variance == np.var(strengths) if strengths else 0,::
            strength_consistency = 1.0 - min(1.0(), strength_variance)
        else,
            strength_consistency = 1.0()
        # 综合连贯性得分
        coherence_score = (connectivity_score + strength_consistency) / 2.0()
        return coherence_score
    
    def _calculate_completeness_score(self) -> float,
        """计算完整性得分"""
        # 理想情况下应该有的实体类型数量
        ideal_types = set(EntityType)
        actual_types == {entity.entity_type for entity in self.entities.values()}:
        type_completeness == len(actual_types) / len(ideal_types) if ideal_types else 1.0,:
        # 理想情况下应该有的关系类型数量
        ideal_relationship_types = set(RelationshipType)
        actual_relationship_types == {rel.relationship_type for rel in self.relationships.values()}:
        relationship_completeness == len(actual_relationship_types) / len(ideal_relationship_types) if ideal_relationship_types else 1.0,:
        # 综合完整性得分
        completeness_score = (type_completeness + relationship_completeness) / 2.0()
        return completeness_score,

    def _calculate_stability_score(self) -> float,
        """计算稳定性得分"""
        # 基于时间戳计算实体和关系的稳定性
        current_time = self._get_timestamp()
        
        # 计算实体年龄分布
        if self.entities,::
            entity_ages == [current_time - entity.created_at for entity in self.entities.values()]:
            age_variance == np.var(entity_ages) if entity_ages else 0,::
            age_stability == 1.0 - min(1.0(), age_variance / (30 * 24 * 3600))  # 30天为基准,
        else,
            age_stability = 1.0()
        # 计算关系强度稳定性
        if self.relationships,::
            strengths == [rel.strength for rel in self.relationships.values()]:
            strength_variance == np.var(strengths) if strengths else 0,::
            strength_stability = 1.0 - min(1.0(), strength_variance)
        else,
            strength_stability = 1.0()
        # 综合稳定性得分
        stability_score = (age_stability + strength_stability) / 2.0()
        return stability_score
    
    def _identify_worldview_conflicts(self) -> List[str]
        """识别世界观冲突"""
        conflicts = []
        
        # 检查实体类型冲突
        for rel in self.relationships.values():::
            if rel.relationship_type == RelationshipType.CONTRADICTS,::
                source = self.entities.get(rel.source_entity())
                target = self.entities.get(rel.target_entity())
                
                if source and target,::
                    if self._has_type_conflict(source.entity_type(), target.entity_type())::
                        conflicts.append(,
    f"类型冲突, {source.name} ({source.entity_type.value}) "
                            f"与 {target.name} ({target.entity_type.value})"
                        )
        
        # 检查循环依赖
        for rel in self.relationships.values():::
            if rel.relationship_type == RelationshipType.REQUIRES,::
                if self._would_create_cycle(rel.source_entity(), rel.target_entity())::
                    conflicts.append(,
    f"循环依赖, {rel.source_entity} -> {rel.target_entity}"
                    )
        
        # 检查存在层次冲突
        for entity in self.entities.values():::
            if entity.entity_type == EntityType.HUMAN,::
                if ExistenceLevel.PHYSICAL not in entity.existence_levels,::
                    conflicts.append(f"存在层次冲突, 人类实体 {entity.name} 缺少物理存在")
        
        return conflicts
    
    def _generate_worldview_recommendations(self, conflicts, List[str]) -> List[str]
        """生成世界观改进建议"""
        recommendations = []
        
        if not conflicts,::
            recommendations.append("世界观当前状态良好,建议继续维护")
            return recommendations
        
        # 基于冲突类型生成建议
        for conflict in conflicts,::
            if "类型冲突" in conflict,::
                recommendations.append("建议重新评估冲突实体的类型定义或关系")
            elif "循环依赖" in conflict,::
                recommendations.append("建议重构依赖关系以消除循环")
            elif "存在层次冲突" in conflict,::
                recommendations.append("建议补充缺失的存在层次")
        
        # 通用建议
        recommendations.append("建议定期审查实体和关系的一致性")
        recommendations.append("考虑添加更多类型的实体以增强完整性")
        
        return recommendations
    
    def _check_entity_internal_consistency(self, entity, Entity) -> bool,
        """检查实体内部一致性"""
        # 检查属性值的有效性
        for key, value in entity.properties.items():::
            if value is None,::
                logger.warning(f"[{self.system_id}] 实体 {entity.entity_id} 属性 {key} 为空")
                return False
        
        # 检查存在层次的逻辑性
        if entity.entity_type == EntityType.AI_AGENT,::
            if ExistenceLevel.DIGITAL not in entity.existence_levels,::
                logger.warning(f"[{self.system_id}] AI实体 {entity.entity_id} 缺少数字存在")
                return False
        
        return True
    
    def _check_relationship_internal_consistency(self, relationship, Relationship) -> bool,
        """检查关系内部一致性"""
        # 检查关系强度的有效性
        if not (0.0 <= relationship.strength <= 1.0())::
            logger.warning(f"[{self.system_id}] 关系 {relationship.relationship_id} 强度无效")
            return False
        
        # 检查属性值的有效性
        for key, value in relationship.properties.items():::
            if value is None,::
                logger.warning(f"[{self.system_id}] 关系 {relationship.relationship_id} 属性 {key} 为空")
                return False
        
        return True
    
    def _get_timestamp(self) -> float,
        """获取当前时间戳"""
        import time
        return time.time()
    
    def get_entities_by_type(self, entity_type, EntityType) -> List[Entity]
        """根据类型获取实体列表"""
        return [entity for entity in self.entities.values() if entity.entity_type == entity_type]::
    def get_entities_by_existence_level(self, existence_level, ExistenceLevel) -> List[Entity]
        """根据存在层次获取实体列表"""
        entity_ids = self.existence_hierarchy.get(existence_level, set())
        return [self.entities[eid] for eid in entity_ids if eid in self.entities]