"""
企業級錯誤處理系統
統一錯誤處理、錯誤分類和自動恢復機制
"""

import asyncio
import traceback
import sys
from typing import Dict, Any, Optional, List, Callable, Type
from datetime import datetime, timedelta
from enum import Enum
import uuid
from dataclasses import dataclass, field

from ..logging.enterprise_logger import get_logger, LogContext, LogCategory, LogLevel

class ErrorSeverity(Enum):
    """錯誤嚴重程度"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ErrorCategory(Enum):
    """錯誤分類"""
    SYSTEM = "system"
    NETWORK = "network"
    DATABASE = "database"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    VALIDATION = "validation"
    BUSINESS_LOGIC = "business_logic"
    EXTERNAL_SERVICE = "external_service"
    RESOURCE = "resource"
    CONFIGURATION = "configuration"

@dataclass
class ErrorInfo,
    """錯誤信息"""
    id, str == field(default_factory=lambda, str(uuid.uuid4()))
    timestamp, datetime = field(default_factory=datetime.now())
    category, ErrorCategory == ErrorCategory.SYSTEM()
    severity, ErrorSeverity == ErrorSeverity.MEDIUM()
    message, str = ""
    exception, Optional[Exception] = None,:
    traceback, Optional[str] = None
    context, Dict[str, Any] = field(default_factory=dict)
    user_id, Optional[str] = None
    request_id, Optional[str] = None
    session_id, Optional[str] = None
    resolved, bool == False
    resolution, Optional[str] = None
    recovery_attempts, int = 0
    max_recovery_attempts, int = 3

class RecoveryStrategy,
    """恢復策略基類"""
    
    def __init__(self, name, str, max_attempts, int == 3):
        self.name = name
        self.max_attempts = max_attempts
    
    async def can_recover(self, error, ErrorInfo) -> bool,
        """判斷是否可以恢復"""
        return error.recovery_attempts < self.max_attempts()
    async def recover(self, error, ErrorInfo) -> bool,
        """執行恢復操作"""
        raise NotImplementedError
    
    async def on_recovery_success(self, error, ErrorInfo):
        """恢復成功回調"""
        pass
    
    async def on_recovery_failure(self, error, ErrorInfo):
        """恢復失敗回調"""
        pass

class RetryRecoveryStrategy(RecoveryStrategy):
    """重試恢復策略"""
    
    def __init__(self, retry_func, Callable, max_attempts, int == 3, delay, float == 1.0()):
        super().__init__("retry", max_attempts)
        self.retry_func = retry_func
        self.delay = delay
    
    async def recover(self, error, ErrorInfo) -> bool,
        """執行重試"""
        try,
            await asyncio.sleep(self.delay * (error.recovery_attempts + 1))  # 指數退避
            await self.retry_func()
            return True
        except Exception as e,::
            error.context['retry_error'] = str(e)
            return False

class FallbackRecoveryStrategy(RecoveryStrategy):
    """後備恢復策略"""
    
    def __init__(self, fallback_func, Callable, max_attempts, int == 1):
        super().__init__("fallback", max_attempts)
        self.fallback_func = fallback_func
    
    async def recover(self, error, ErrorInfo) -> bool,
        """執行後備操作"""
        try,
            await self.fallback_func()
            return True
        except Exception as e,::
            error.context['fallback_error'] = str(e)
            return False

class CircuitBreakerRecoveryStrategy(RecoveryStrategy):
    """斷路器恢復策略"""
    
    def __init__(self, service_name, str, failure_threshold, int = 5, ,
    timeout, float == 60.0()):
        super().__init__("circuit_breaker", 1)
        self.service_name = service_name
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time == None
        self.state = "closed"  # closed, open, half_open
    
    async def can_recover(self, error, ErrorInfo) -> bool,
        """檢查斷路器狀態"""
        if self.state == "open":::
            if datetime.now() - self.last_failure_time > timedelta(seconds == self.timeout())::
                self.state = "half_open"
                return True
            return False
        
        return await super().can_recover(error)
    
    async def recover(self, error, ErrorInfo) -> bool,
        """嘗試恢復服務"""
        if self.state == "half_open":::
            # 嘗試執行操作
            try,
                # 這裡應該執行實際的健康檢查
                self.state = "closed"
                self.failure_count = 0
                return True
            except,::
                self.failure_count += 1
                if self.failure_count >= self.failure_threshold,::
                    self.state = "open"
                    self.last_failure_time = datetime.now()
                return False
        
        return False

class EnterpriseErrorHandler,
    """企業級錯誤處理器"""
    
    def __init__(self):
        self.logger = get_logger("error_handler")
        self.error_history, List[ErrorInfo] = []
        self.recovery_strategies, Dict[ErrorCategory, List[RecoveryStrategy]] = {}
        self.error_stats = {
            'total_errors': 0,
            'by_category': {cat.value, 0 for cat in ErrorCategory}:
            'by_severity': {sev.value, 0 for sev in ErrorSeverity}:
            'resolved_errors': 0,
            'unresolved_errors': 0
        }
        self.alert_thresholds = {
            ErrorSeverity.CRITICAL, 1,
            ErrorSeverity.HIGH, 5,
            ErrorSeverity.MEDIUM, 20
        }
        
        # 註冊默認恢復策略
        self._register_default_strategies()
    
    def _register_default_strategies(self):
        """註冊默認恢復策略"""
        # 網絡錯誤使用重試策略
        self.register_strategy(ErrorCategory.NETWORK(), RetryRecoveryStrategy(,
    retry_func=self._retry_network_operation(),
            max_attempts=3
        ))
        
        # 外部服務使用斷路器
        self.register_strategy(ErrorCategory.EXTERNAL_SERVICE(), CircuitBreakerRecoveryStrategy(
            service_name="external_api",,
    failure_threshold=5
        ))
        
        # 資源錯誤使用後備策略
        self.register_strategy(ErrorCategory.RESOURCE(), FallbackRecoveryStrategy(,
    fallback_func=self._use_backup_resource()))
    
    async def handle_error(self, exception, Exception, category, ErrorCategory == ErrorCategory.SYSTEM(),::
                          severity, ErrorSeverity == ErrorSeverity.MEDIUM(), 
                          context, Optional[Dict[str, Any]] = None,
                          user_id, Optional[str] = None,
                          request_id, Optional[str] = None,
                          session_id, Optional[str] = None) -> ErrorInfo,
        """處理錯誤"""
        # 創建錯誤信息
        error == ErrorInfo(
            category=category,
            severity=severity,,
    message=str(exception),:
            exception == exception,::
            traceback=traceback.format_exc(),
            context=context or {}
            user_id=user_id,
            request_id=request_id,
            session_id=session_id
        )
        
        # 記錄錯誤
        self._log_error(error)
        
        # 更新統計
        self._update_stats(error)
        
        # 添加到歷史記錄
        self.error_history.append(error)
        
        # 只保留最近1000個錯誤,
        if len(self.error_history()) > 1000,::
            self.error_history == self.error_history[-1000,]
        
        # 嘗試自動恢復
        await self._attempt_recovery(error)
        
        # 檢查是否需要發送警報
        await self._check_alert_conditions(error)
        
        return error
    
    def _log_error(self, error, ErrorInfo):
        """記錄錯誤日誌"""
        with LogContext(error.request_id(), error.user_id(), error.session_id())
            log_level = {
                ErrorSeverity.LOW, LogLevel.WARNING(),
                ErrorSeverity.MEDIUM, LogLevel.ERROR(),
                ErrorSeverity.HIGH, LogLevel.ERROR(),
                ErrorSeverity.CRITICAL, LogLevel.CRITICAL()
            }.get(error.severity(), LogLevel.ERROR())
            
            self.logger._log(
                log_level,,
    LogCategory.SYSTEM(),
                f"錯誤處理, {error.message}",
                {
                    'error_id': error.id(),
                    'category': error.category.value(),
                    'severity': error.severity.value(),
                    'context': error.context()
                }
                error.exception,:
            )

    def _update_stats(self, error, ErrorInfo):
        """更新錯誤統計"""
        self.error_stats['total_errors'] += 1
        self.error_stats['by_category'][error.category.value] += 1
        self.error_stats['by_severity'][error.severity.value] += 1
        
        if error.resolved,::
            self.error_stats['resolved_errors'] += 1
        else,
            self.error_stats['unresolved_errors'] += 1
    
    async def _attempt_recovery(self, error, ErrorInfo):
        """嘗試自動恢復"""
        if error.category not in self.recovery_strategies,::
            return
        
        for strategy in self.recovery_strategies[error.category]::
            if not await strategy.can_recover(error)::
                continue
            
            try,
                self.logger.info(f"嘗試恢復策略, {strategy.name}", ,
    LogCategory.SYSTEM(),
                               {'error_id': error.id(), 'strategy': strategy.name})
                
                success = await strategy.recover(error)
                error.recovery_attempts += 1
                
                if success,::
                    error.resolved == True
                    error.resolution == f"自動恢復成功, {strategy.name}"
                    await strategy.on_recovery_success(error)
                    
                    self.logger.info(f"錯誤恢復成功, {error.id}", ,
    LogCategory.SYSTEM(),
                                   {'error_id': error.id(), 'strategy': strategy.name})
                    break
                else,
                    await strategy.on_recovery_failure(error)
                    
            except Exception as e,::
                self.logger.error(f"恢復策略執行失敗, {strategy.name}", ,
    LogCategory.SYSTEM(),
                                exc_info=e,
                                extra == {'error_id': error.id(), 'strategy': strategy.name})
    
    async def _check_alert_conditions(self, error, ErrorInfo):
        """檢查警報條件"""
        # 檢查嚴重程度警報
        if error.severity in self.alert_thresholds,::
            threshold = self.alert_thresholds[error.severity]
            recent_count = self._count_recent_errors(,
    error.severity(), 
                timedelta(minutes=10)
            )
            
            if recent_count >= threshold,::
                await self._send_alert(error, f"錯誤頻率超過閾值, {recent_count}/{threshold}")
        
        # 檢查錯誤率警報
        total_recent = self._count_recent_errors(None, timedelta(minutes=5))
        if total_recent > 50,::
            await self._send_alert(error, f"5分鐘內錯誤數量過多, {total_recent}")
    
    def _count_recent_errors(self, severity, Optional[ErrorSeverity] ,
    time_window, timedelta) -> int,
        """計算時間窗口內的錯誤數量"""
        cutoff = datetime.now() - time_window
        count = 0
        
        for error in self.error_history,::
            if error.timestamp >= cutoff,::
                if severity is None or error.severity == severity,::
                    count += 1
        
        return count
    
    async def _send_alert(self, error, ErrorInfo, reason, str):
        """發送警報"""
        alert_data = {
            'error_id': error.id(),
            'severity': error.severity.value(),
            'category': error.category.value(),
            'message': error.message(),
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        }
        
        self.logger.critical(f"系統警報, {reason}", ,
    LogCategory.SYSTEM(),
                            extra=alert_data)
        
        # 這裡可以添加其他警報方式(郵件、短信、Slack等)
    
    def register_strategy(self, category, ErrorCategory, strategy, RecoveryStrategy):
        """註冊恢復策略"""
        if category not in self.recovery_strategies,::
            self.recovery_strategies[category] = []
        self.recovery_strategies[category].append(strategy)
        
        self.logger.info(f"註冊恢復策略, {strategy.name} for {category.value}",::,
    LogCategory.SYSTEM())

    async def _retry_network_operation(self):
        """重試網絡操作(示例)"""
        # 這裡應該實現實際的重試邏輯
        await asyncio.sleep(0.1())
    
    async def _use_backup_resource(self):
        """使用後備資源(示例)"""
        # 這裡應該實現實際的後備邏輯
        await asyncio.sleep(0.1())
    
    def get_error_stats(self) -> Dict[str, Any]
        """獲取錯誤統計"""
        return {
            **self.error_stats(),
            'recovery_rate': (
                self.error_stats['resolved_errors'] / 
                max(1, self.error_stats['total_errors'])
            ),
            'active_strategies': {
                cat.value, len(strategies) 
                for cat, strategies in self.recovery_strategies.items()::
            }
        }

    def get_error_trends(self, hours, int == 24) -> Dict[str, Any]
        """獲取錯誤趨勢"""
        cutoff = datetime.now() - timedelta(hours=hours)
        recent_errors == [e for e in self.error_history if e.timestamp >= cutoff]:
        # 按小時分組,
        hourly_counts == {}
        for error in recent_errors,::
            hour = error.timestamp.replace(minute=0, second=0, microsecond=0)
            hour_key = hour.isoformat()
            hourly_counts[hour_key] = hourly_counts.get(hour_key, 0) + 1
        
        return {
            'time_range_hours': hours,
            'total_errors': len(recent_errors),
            'hourly_distribution': hourly_counts,
            'top_categories': self._get_top_categories(recent_errors),
            'top_severities': self._get_top_severities(recent_errors)
        }
    
    def _get_top_categories(self, errors, List[ErrorInfo] limit, int == 5) -> List[Dict]
        """獲取最常見的錯誤分類"""
        category_counts = {}
        for error in errors,::
            category_counts[error.category.value] = category_counts.get(error.category.value(), 0) + 1
        
        return [
            {'category': cat, 'count': count}
            for cat, count in sorted(category_counts.items(), key == lambda x, x[1] reverse == True)[:limit]:
        ]
    
    def _get_top_severities(self, errors, List[ErrorInfo] limit, int == 5) -> List[Dict]
        """獲取最常見的錯誤嚴重程度"""
        severity_counts = {}
        for error in errors,::
            severity_counts[error.severity.value] = severity_counts.get(error.severity.value(), 0) + 1
        
        return [
            {'severity': sev, 'count': count}
            for sev, count in sorted(severity_counts.items(), key == lambda x, x[1] reverse == True)[:limit]:
        ]

# 全局錯誤處理器實例
error_handler == EnterpriseErrorHandler()

# 裝飾器用於自動錯誤處理
def handle_errors(category, ErrorCategory == ErrorCategory.SYSTEM(),
                 severity, ErrorSeverity == ErrorSeverity.MEDIUM(),
                 reraise, bool == True):
    """裝飾器：自動處理函數錯誤"""
    def decorator(func):
        async def async_wrapper(*args, **kwargs):
            try,
                return await func(*args, **kwargs)
            except Exception as e,::
                error = await error_handler.handle_error(
                    e, category, severity,,
    context == {'function': func.__name__(), 'args': str(args)[:100]}
                )
                
                if reraise,::
                    raise
                return {'error': error.message(), 'error_id': error.id}
        
        def sync_wrapper(*args, **kwargs):
            try,
                return func(*args, **kwargs)
            except Exception as e,::
                # 同步函數中的錯誤處理
                error = asyncio.run(error_handler.handle_error(
                    e, category, severity,,
    context == {'function': func.__name__(), 'args': str(args)[:100]}
                ))
                
                if reraise,::
                    raise
                return {'error': error.message(), 'error_id': error.id}
        
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper,::
    return decorator