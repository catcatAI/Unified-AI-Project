#!/usr/bin/env python3
"""
缓存管理器 - 企业级缓存系统
支持多级缓存、分布式缓存和智能缓存策略
"""

import json
import time
import hashlib
import asyncio
import logging
from typing import Any, Dict, Optional, Union, List
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
import threading
from collections import OrderedDict
import pickle
import redis.asyncio as redis
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class CacheLevel(Enum):
    """缓存级别"""
    MEMORY = "memory"
    REDIS = "redis"
    DISTRIBUTED = "distributed"

@dataclass
class CacheConfig:
    """缓存配置"""
    default_ttl: int = 3600  # 默认TTL（秒）
    max_memory_size: int = 1000  # 内存缓存最大条目数
    redis_url: str = "redis://localhost:6379"
    redis_db: int = 0
    enable_compression: bool = True
    enable_serialization: bool = True
    eviction_policy: str = "lru"  # lru, lfu, ttl

class CacheBackend(ABC):
    """缓存后端抽象基类"""
    
    @abstractmethod
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        pass
    
    @abstractmethod
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """设置缓存值"""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """删除缓存"""
        pass
    
    @abstractmethod
    async def clear(self) -> bool:
        """清空缓存"""
        pass
    
    @abstractmethod
    async def exists(self, key: str) -> bool:
        """检查键是否存在"""
        pass

class MemoryCache(CacheBackend):
    """内存缓存实现"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache = OrderedDict()
        self.lock = threading.Lock()
    
    async def get(self, key: str) -> Optional[Any]:
        with self.lock:
            if key in self.cache:
                value, timestamp, ttl = self.cache[key]
                if ttl and time.time() - timestamp > ttl:
                    del self.cache[key]
                    return None
                # 移到末尾（最近使用）
                self.cache.move_to_end(key)
                return value
            return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            else:
                if len(self.cache) >= self.max_size:
                    # 删除最久未使用的项
                    self.cache.popitem(last=False)
            
            self.cache[key] = (value, time.time(), ttl)
            return True
    
    async def delete(self, key: str) -> bool:
        with self.lock:
            if key in self.cache:
                del self.cache[key]
                return True
            return False
    
    async def clear(self) -> bool:
        with self.lock:
            self.cache.clear()
            return True
    
    async def exists(self, key: str) -> bool:
        with self.lock:
            return key in self.cache

class RedisCache(CacheBackend):
    """Redis缓存实现"""
    
    def __init__(self, redis_url: str, db: int = 0):
        self.redis_url = redis_url
        self.db = db
        self.client = None
    
    async def _get_client(self):
        """获取Redis客户端"""
        if self.client is None:
            self.client = redis.from_url(self.redis_url, db=self.db)
        return self.client
    
    async def get(self, key: str) -> Optional[Any]:
        try:
            client = await self._get_client()
            value = await client.get(key)
            if value:
                return pickle.loads(value)
            return None
        except Exception as e:
            logger.error(f"Redis get error: {e}")
            return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        try:
            client = await self._get_client()
            serialized = pickle.dumps(value)
            if ttl:
                return await client.setex(key, ttl, serialized)
            else:
                return await client.set(key, serialized)
        except Exception as e:
            logger.error(f"Redis set error: {e}")
            return False
    
    async def delete(self, key: str) -> bool:
        try:
            client = await self._get_client()
            return bool(await client.delete(key))
        except Exception as e:
            logger.error(f"Redis delete error: {e}")
            return False
    
    async def clear(self) -> bool:
        try:
            client = await self._get_client()
            return await client.flushdb()
        except Exception as e:
            logger.error(f"Redis clear error: {e}")
            return False
    
    async def exists(self, key: str) -> bool:
        try:
            client = await self._get_client()
            return bool(await client.exists(key))
        except Exception as e:
            logger.error(f"Redis exists error: {e}")
            return False

class CacheManager:
    """多级缓存管理器"""
    
    def __init__(self, config: CacheConfig = None):
        self.config = config or CacheConfig()
        self.backends = {}
        self.stats = {
            "hits": 0,
            "misses": 0,
            "sets": 0,
            "deletes": 0
        }
        
        # 初始化缓存后端
        self._init_backends()
        
        logger.info("缓存管理器初始化完成")
    
    def _init_backends(self):
        """初始化缓存后端"""
        # 内存缓存
        self.backends[CacheLevel.MEMORY] = MemoryCache(self.config.max_memory_size)
        
        # Redis缓存
        try:
            self.backends[CacheLevel.REDIS] = RedisCache(
                self.config.redis_url, 
                self.config.redis_db
            )
            logger.info("Redis缓存后端初始化成功")
        except Exception as e:
            logger.warning(f"Redis缓存初始化失败: {e}")
    
    async def get(self, key: str, level: CacheLevel = CacheLevel.MEMORY) -> Optional[Any]:
        """获取缓存值"""
        # 尝试从指定级别获取
        if level in self.backends:
            value = await self.backends[level].get(key)
            if value is not None:
                self.stats["hits"] += 1
                return value
        
        # 多级缓存策略：从内存 -> Redis
        if level != CacheLevel.MEMORY and CacheLevel.MEMORY in self.backends:
            value = await self.backends[CacheLevel.MEMORY].get(key)
            if value is not None:
                # 回填到指定级别
                await self.set(key, value, level=level)
                self.stats["hits"] += 1
                return value
        
        if level != CacheLevel.REDIS and CacheLevel.REDIS in self.backends:
            value = await self.backends[CacheLevel.REDIS].get(key)
            if value is not None:
                # 回填到内存
                await self.set(key, value, level=CacheLevel.MEMORY)
                self.stats["hits"] += 1
                return value
        
        self.stats["misses"] += 1
        return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None, level: CacheLevel = CacheLevel.MEMORY) -> bool:
        """设置缓存值"""
        if level in self.backends:
            success = await self.backends[level].set(key, value, ttl)
            if success:
                self.stats["sets"] += 1
            return success
        return False
    
    async def delete(self, key: str, level: CacheLevel = CacheLevel.MEMORY) -> bool:
        """删除缓存"""
        success = False
        if level in self.backends:
            if await self.backends[level].delete(key):
                success = True
                self.stats["deletes"] += 1
        
        # 多级删除
        if level != CacheLevel.MEMORY and CacheLevel.MEMORY in self.backends:
            await self.backends[CacheLevel.MEMORY].delete(key)
        
        if level != CacheLevel.REDIS and CacheLevel.REDIS in self.backends:
            await self.backends[CacheLevel.REDIS].delete(key)
        
        return success
    
    async def clear(self, level: CacheLevel = CacheLevel.MEMORY) -> bool:
        """清空缓存"""
        if level in self.backends:
            return await self.backends[level].clear()
        return False
    
    async def exists(self, key: str, level: CacheLevel = CacheLevel.MEMORY) -> bool:
        """检查键是否存在"""
        if level in self.backends:
            return await self.backends[level].exists(key)
        return False
    
    def get_stats(self) -> Dict[str, Any]:
        """获取缓存统计"""
        total_requests = self.stats["hits"] + self.stats["misses"]
        hit_rate = (self.stats["hits"] / total_requests * 100) if total_requests > 0 else 0
        
        return {
            **self.stats,
            "hit_rate": hit_rate,
            "total_requests": total_requests
        }
    
    def reset_stats(self):
        """重置统计"""
        self.stats = {
            "hits": 0,
            "misses": 0,
            "sets": 0,
            "deletes": 0
        }

class CacheDecorator:
    """缓存装饰器"""
    
    def __init__(self, cache_manager: CacheManager, ttl: int = 3600, level: CacheLevel = CacheLevel.MEMORY):
        self.cache_manager = cache_manager
        self.ttl = ttl
        self.level = level
    
    def __call__(self, key_func=None):
        def decorator(func):
            async def wrapper(*args, **kwargs):
                # 生成缓存键
                if key_func:
                    cache_key = key_func(*args, **kwargs)
                else:
                    cache_key = self._generate_key(func.__name__, args, kwargs)
                
                # 尝试从缓存获取
                cached_result = await self.cache_manager.get(cache_key, self.level)
                if cached_result is not None:
                    return cached_result
                
                # 执行函数
                result = await func(*args, **kwargs)
                
                # 缓存结果
                await self.cache_manager.set(cache_key, result, self.ttl, self.level)
                
                return result
            return wrapper
        return decorator
    
    def _generate_key(self, func_name: str, args: tuple, kwargs: dict) -> str:
        """生成缓存键"""
        key_data = {
            "func": func_name,
            "args": args,
            "kwargs": kwargs
        }
        key_str = json.dumps(key_data, sort_keys=True, default=str)
        return hashlib.md5(key_str.encode()).hexdigest()

# 全局缓存管理器
cache_manager = CacheManager()

# 便捷装饰器
def cached(ttl: int = 3600, level: CacheLevel = CacheLevel.MEMORY, key_func=None):
    """缓存装饰器"""
    return CacheDecorator(cache_manager, ttl, level)(key_func)

class CacheWarmer:
    """缓存预热器"""
    
    def __init__(self, cache_manager: CacheManager):
        self.cache_manager = cache_manager
    
    async def warm_cache(self, warmup_data: Dict[str, Any]):
        """预热缓存"""
        logger.info(f"开始缓存预热，共 {len(warmup_data)} 项")
        
        for key, value in warmup_data.items():
            await self.cache_manager.set(key, value)
        
        logger.info("缓存预热完成")
    
    async def warm_function_cache(self, func, args_list: List[tuple]):
        """预热函数缓存"""
        logger.info(f"预热函数缓存: {func.__name__}")
        
        for args in args_list:
            try:
                result = await func(*args)
                cache_key = self._generate_func_key(func.__name__, args)
                await self.cache_manager.set(cache_key, result)
            except Exception as e:
                logger.error(f"预热函数缓存失败: {e}")
    
    def _generate_func_key(self, func_name: str, args: tuple) -> str:
        """生成函数缓存键"""
        key_data = {"func": func_name, "args": args}
        key_str = json.dumps(key_data, sort_keys=True, default=str)
        return hashlib.md5(key_str.encode()).hexdigest()

class CacheInvalidation:
    """缓存失效管理"""
    
    def __init__(self, cache_manager: CacheManager):
        self.cache_manager = cache_manager
        self.patterns = {}
    
    def register_pattern(self, pattern: str, keys: List[str]):
        """注册失效模式"""
        self.patterns[pattern] = keys
    
    async def invalidate_by_pattern(self, pattern: str):
        """按模式失效缓存"""
        if pattern in self.patterns:
            for key in self.patterns[pattern]:
                await self.cache_manager.delete(key)
    
    async def invalidate_by_prefix(self, prefix: str):
        """按前缀失效缓存"""
        # 这里需要根据具体实现来支持模式匹配
        # Redis支持KEYS命令，内存缓存需要遍历
        pass

# 使用示例
@cached(ttl=600, level=CacheLevel.MEMORY)
async def expensive_computation(x: int, y: int) -> int:
    """耗时计算函数"""
    await asyncio.sleep(1)  # 模拟耗时操作
    return x * y

async def main():
    """示例使用"""
    # 设置缓存
    await cache_manager.set("test_key", {"data": "test"}, ttl=60)
    
    # 获取缓存
    result = await cache_manager.get("test_key")
    print(f"缓存结果: {result}")
    
    # 使用装饰器
    result = await expensive_computation(5, 10)
    print(f"计算结果: {result}")
    
    # 再次调用将使用缓存
    result = await expensive_computation(5, 10)
    print(f"缓存结果: {result}")
    
    # 查看统计
    stats = cache_manager.get_stats()
    print(f"缓存统计: {stats}")

if __name__ == "__main__":
    asyncio.run(main())