"""
智能化测试用例生成器实现
基于EXECUTION_PLAN_ADVANCED_TESTING_DEBUGGING.md设计文档
"""

import logging
import ast
from enum import Enum
from typing import Any, List, Dict, Optional

logger = logging.getLogger(__name__)


class TestType(Enum):
    """测试类型枚举"""
    UNIT_TEST = "unit_test"
    INTEGRATION_TEST = "integration_test"
    FUNCTIONAL_TEST = "functional_test"
    PERFORMANCE_TEST = "performance_test"
    SECURITY_TEST = "security_test"


@dataclass
class TestParameter:
    """测试参数"""
    name: str
    type_hint: str
    default_value: Any = None
    description: str = ""


@dataclass
class TestCase:
    """测试用例"""
    name: str
    description: str
    test_type: TestType
    function_name: str
    parameters: List[TestParameter]
    expected_behavior: str
    test_code: str = ""
    priority: int = 1  # 1-5, 5为最高优先级


class CodeAnalyzer:
    """代码分析器"""

    def __init__(self) -> None:
        self.functions: Dict[str, Dict[str, Any]] = {}
        self.classes: Dict[str, Dict[str, Any]] = {}

    def analyze_file(self, file_path: str) -> Dict[str, Any]:
        """分析Python文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                source_code = f.read()

            # 解析AST
            tree = ast.parse(source_code)

            # 分析函数和类
            functions = self._extract_functions(tree)
            classes = self._extract_classes(tree)

            return {
                "file_path": file_path,
                "functions": functions,
                "classes": classes
            }
        except Exception as e:
            _ = logger.error(f"Failed to analyze file {file_path}: {e}")
            return {}

    def _extract_functions(self, tree: ast.AST) -> Dict[str, Dict[str, Any]]:
        """提取函数信息"""
        functions = {}

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                func_info = {
                    "name": node.name,
                    "parameters": self._extract_parameters(node),
                    "return_type": self._extract_return_type(node),
                    "docstring": ast.get_docstring(node),
                    "line_number": node.lineno,
                    "decorators": [self._extract_decorator(d) for d in node.decorator_list]:

                functions[node.name] = func_info

        return functions

    def _extract_classes(self, tree: ast.AST) -> Dict[str, Dict[str, Any]]:
        """提取类信息"""
        classes = {}

        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                class_info = {
                    "name": node.name,
                    "methods": self._extract_functions(node),
                    "docstring": ast.get_docstring(node),
                    "line_number": node.lineno,
                    "bases": [self._extract_base(b) for b in node.bases]:

                classes[node.name] = class_info

        return classes

    def _extract_parameters(
        self, func_node: ast.FunctionDef) -> List[Dict[str, Any]]:
        """提取函数参数"""
        parameters = []

        args = func_node.args
        defaults = args.defaults
        num_defaults = len(defaults)
        num_args = len(args.args)

        # 处理位置参数
        for i, arg in enumerate(args.args):
            param_info = {
                "name": arg.arg,
                "type_annotation": self._extract_type_annotation(arg.annotation) if arg.annotation else None:


            # 处理默认值
            if i >= num_args - num_defaults:
                default_idx = i - (num_args - num_defaults)
                param_info["default"] = self._extract_default_value(
                    defaults[default_idx])
            else:
                param_info["default"] = None

            _ = parameters.append(param_info)

        # 处理*args
        if args.vararg:
            parameters.append({
                "name": "*" + args.vararg.arg,
                "type_annotation": self._extract_type_annotation(args.vararg.annotation) if args.vararg.annotation else None,
                "default": None
            })

        # 处理**kwargs
        if args.kwarg:
            parameters.append({
                "name": "**" + args.kwarg.arg,
                "type_annotation": self._extract_type_annotation(args.kwarg.annotation) if args.kwarg.annotation else None,
                "default": None
            })

        return parameters

    def _extract_type_annotation(self, annotation: ast.AST) -> str:
        """提取类型注解"""
        if isinstance(annotation, ast.Name):
            # 修复: 确保ast.Name节点有id属性
            return getattr(annotation, 'id', 'Any')
        elif isinstance(annotation, ast.Constant):
            return str(annotation.value)
        elif isinstance(annotation, ast.Subscript):
            if isinstance(annotation.value, ast.Name):
                # 修复: 确保ast.Name节点有id属性
                base = getattr(annotation.value, 'id', 'Any')
                if isinstance(annotation.slice, ast.Name):
                    # 修复: 确保ast.Name节点有id属性
                    return f"{base}[{getattr(annotation.slice, 'id', 'Any')}]"
                elif isinstance(annotation.slice, ast.Tuple):
                    slice_items = []
                    for elt in annotation.slice.elts:
                        if isinstance(elt, ast.Name):
                            # 修复: 确保ast.Name节点有id属性
                            _ = slice_items.append(getattr(elt, 'id', 'Any'))
                    return f"{base}[{', '.join(slice_items)}]"
        return "Any"

    def _extract_return_type(self, func_node: ast.FunctionDef) -> str:
        """提取返回类型"""
        if func_node.returns:
            return self._extract_type_annotation(func_node.returns)
        return "Any"

    def _extract_default_value(self, default_node: Optional[ast.AST]) -> Any:
        """提取默认值"""
        if default_node is None:
            return None
        elif isinstance(default_node, ast.Constant):
            return default_node.value
        elif isinstance(default_node, ast.NameConstant):
            return default_node.value
        elif isinstance(default_node, ast.Num):
            return default_node.n
        elif isinstance(default_node, ast.Str):
            return default_node.s
        elif isinstance(default_node, ast.List):
            result = []
            for elt in default_node.elts:
                _ = result.append(self._extract_default_value(elt))
            return result
        elif isinstance(default_node, ast.Dict):
            keys = []
            values = []
            for key, value in zip(default_node.keys, default_node.values):
                if key is not None:
                    _ = keys.append(self._extract_default_value(key))
                else:
                    _ = keys.append(None)
                _ = values.append(self._extract_default_value(value))
            return dict(zip(keys, values))
        return None

    def _extract_decorator(self, decorator_node: ast.AST) -> str:
        """提取装饰器"""
        if isinstance(decorator_node, ast.Name):
            # 修复: 确保ast.Name节点有id属性
            return getattr(decorator_node, 'id', 'unknown')
        elif isinstance(decorator_node, ast.Attribute):
            # 修复: 确保ast.Attribute节点的value有id属性
            value_id = getattr(decorator_node.value, 'id', 'unknown') if hasattr(decorator_node.value, 'id') else 'unknown':
eturn f"{value_id}.{decorator_node.attr}"
        elif isinstance(decorator_node, ast.Call):
            if isinstance(decorator_node.func, ast.Name):
                # 修复: 确保ast.Name节点有id属性
                return getattr(decorator_node.func, 'id', 'unknown')
            elif isinstance(decorator_node.func, ast.Attribute):
                # 修复: 确保ast.Attribute节点的value有id属性
                value_id = getattr(decorator_node.func.value, 'id', 'unknown') if hasattr(decorator_node.func.value, 'id') else 'unknown':
eturn f"{value_id}.{decorator_node.func.attr}"
        return "unknown"

    def _extract_base(self, base_node: ast.AST) -> str:
        """提取基类"""
        if isinstance(base_node, ast.Name):
            # 修复: 确保ast.Name节点有id属性
            return getattr(base_node, 'id', 'object')
        elif isinstance(base_node, ast.Attribute):
            # 修复: 确保ast.Attribute节点的value有id属性
            value_id = getattr(base_node.value, 'id', 'unknown') if hasattr(base_node.value, 'id') else 'unknown':
eturn f"{value_id}.{base_node.attr}"
        return "object"


class TestPatternAnalyzer:
    """测试模式分析器"""

    def __init__(self) -> None:
        self.common_patterns = {
            "validation": ["validate", "check", "verify", "assert"],
            "calculation": ["calculate", "compute", "sum", "average", "total"],
            "data_processing": ["process", "transform", "convert", "parse", "format"],
            "file_operations": ["read", "write", "save", "load", "open", "close"],
            "network_operations": ["send", "receive", "connect", "disconnect", "fetch"],
            "error_handling": ["handle", "catch", "raise", "throw"],
            "database_operations": ["query", "insert", "update", "delete", "find"],
            "authentication": ["login", "logout", "authenticate", "authorize"],
            "encryption": ["encrypt", "decrypt", "hash", "sign"],
        }

    def identify_function_patterns(
        self, function_info: Dict[str, Any]) -> List[str]:
        """识别函数模式"""
        patterns = []
        func_name = function_info["name"].lower()

        # 根据函数名识别模式
        for pattern, keywords in self.common_patterns.items():
            if any(keyword in func_name for keyword in keywords):
                _ = patterns.append(pattern)

        # 根据参数识别模式
        params = function_info.get("parameters", [])
        param_names = [p["name"].lower() for p in params]:
f "password" in param_names or "token" in param_names:
            _ = patterns.append("authentication")

        if "file" in param_names or "path" in param_names:
            _ = patterns.append("file_operations")

        if "url" in param_names or "host" in param_names:
            _ = patterns.append("network_operations")

        return list(set(patterns))  # 去重


class IntelligentTestGenerator:
    """智能化测试用例生成器"""

    def __init__(self) -> None:
        self.code_analyzer = CodeAnalyzer()
        self.pattern_analyzer = TestPatternAnalyzer()
        self.generated_tests: List[TestCase] = []

    def generate_tests_for_file(self, file_path: str) -> List[TestCase]:
        """为文件生成测试用例"""
        try:
            # 分析代码
            analysis_result = self.code_analyzer.analyze_file(file_path)
            if not analysis_result:
                return []

            test_cases = []

            # 为每个函数生成测试用例
            for func_name, func_info in analysis_result["functions"].items():
                func_test_cases = self._generate_function_tests(
                    func_info, analysis_result)
                _ = test_cases.extend(func_test_cases)

            # 为每个类生成测试用例
            for class_name, class_info in analysis_result["classes"].items():
                class_test_cases = self._generate_class_tests(
                    class_info, analysis_result)
                _ = test_cases.extend(class_test_cases)

            # 保存生成的测试用例
            _ = self.generated_tests.extend(test_cases)

            logger.info(f"Generated {len(test_cases)} test cases for {file_path}"):
eturn test_cases
        except Exception as e:
            logger.error(f"Failed to generate tests for {file_path}: {e}"):
eturn[]

    def _generate_function_tests(
        self, func_info: Dict[str, Any], analysis_result: Dict[str, Any]) -> List[TestCase]:
        """为函数生成测试用例"""
        test_cases = []
        func_name = func_info["name"]

        # 识别函数模式
        patterns = self.pattern_analyzer.identify_function_patterns(func_info)

        # 生成基本功能测试
        basic_test = self._create_basic_function_test(func_info)
        if basic_test:
            _ = test_cases.append(basic_test)

        # 根据模式生成特定测试
        for pattern in patterns:
            pattern_tests = self._create_pattern_specific_tests(
                func_info, pattern)
            _ = test_cases.extend(pattern_tests)

        # 生成边界条件测试
        boundary_tests = self._create_boundary_tests(func_info)
        _ = test_cases.extend(boundary_tests)

        # 生成错误处理测试
        error_tests = self._create_error_handling_tests(func_info)
        _ = test_cases.extend(error_tests)

        return test_cases

    def _create_basic_function_test(
        self, func_info: Dict[str, Any]) -> Optional[TestCase]:
        """创建基本功能测试"""
        func_name = func_info["name"]
        parameters = func_info.get("parameters", [])

        # 创建测试参数
        test_params = []
        for param in parameters:
            test_param = TestParameter(
                name=param["name"],
                type_hint=param.get("type_annotation", "Any"),
                default_value=param.get("default"),
                description=f"Parameter for {func_name}":

            _=test_params.append(test_param)

        # 创建测试用例
        test_case=TestCase(
            name=f"test_{func_name}_basic",
            description=f"Basic test for {func_name}", :
est_type=TestType.UNIT_TEST,
            function_name=func_name,
            parameters=test_params,
            expected_behavior=f"Function {func_name} executes without errors",
            priority=3
        )

        return test_case

    def _create_pattern_specific_tests(
        self, func_info: Dict[str, Any], pattern: str) -> List[TestCase]:
        """创建模式特定测试"""
        test_cases=[]
        func_name=func_info["name"]

        if pattern == "validation":
            # 验证函数测试
            invalid_test=TestCase(
                name=f"test_{func_name}_invalid_input",
                description=f"Test {func_name} with invalid input", :
est_type=TestType.UNIT_TEST,
                function_name=func_name,
                parameters=[],
                expected_behavior=f"Function {func_name} raises appropriate exception for invalid input", :
riority=4
            )
            _=test_cases.append(invalid_test)

        elif pattern == "calculation":
            # 计算函数测试
            edge_case_test=TestCase(
                name=f"test_{func_name}_edge_cases",
                description=f"Test {func_name} with edge cases", :
est_type=TestType.UNIT_TEST,
                function_name=func_name,
                parameters=[],
                expected_behavior=f"Function {func_name} handles edge cases correctly",
                priority=3
            )
            _=test_cases.append(edge_case_test)

        elif pattern == "file_operations":
            # 文件操作测试
            file_not_found_test=TestCase(
                name=f"test_{func_name}_file_not_found",
                description=f"Test {func_name} when file does not exist",
                test_type=TestType.UNIT_TEST,
                function_name=func_name,
                parameters=[],
                expected_behavior=f"Function {func_name} handles file not found gracefully",
                priority=4
            )
            _=test_cases.append(file_not_found_test)

        return test_cases

    def _create_boundary_tests(
        self, func_info: Dict[str, Any]) -> List[TestCase]:
        """创建边界条件测试"""
        test_cases=[]
        func_name=func_info["name"]
        parameters=func_info.get("parameters", [])

        # 为空参数生成测试
        if parameters:
            empty_params_test=TestCase(
                name=f"test_{func_name}_empty_parameters",
                description=f"Test {func_name} with empty parameters", :
est_type=TestType.UNIT_TEST,
                function_name=func_name,
                parameters=[],
                expected_behavior=f"Function {func_name} handles empty parameters gracefully",
                priority=3
            )
            _=test_cases.append(empty_params_test)

        return test_cases

    def _create_error_handling_tests(
        self, func_info: Dict[str, Any]) -> List[TestCase]:
        """创建错误处理测试"""
        test_cases=[]
        func_name=func_info["name"]

        # 通用错误处理测试
        error_test=TestCase(
                name=f"test_{func_name}_error_handling",
                description=f"Test error handling in {func_name}",
                test_type=TestType.UNIT_TEST,
                function_name=func_name,
                parameters=[],
                expected_behavior=f"Function {func_name} handles errors appropriately",
                priority=4
            )
        _=test_cases.append(error_test)

        return test_cases

    def _generate_class_tests(
        self, class_info: Dict[str, Any], analysis_result: Dict[str, Any]) -> List[TestCase]:
        """为类生成测试用例"""
        test_cases=[]
        class_name=class_info["name"]

        # 为每个方法生成测试
        for method_name, method_info in class_info["methods"].items():
            method_test_cases=self._generate_function_tests(
                method_info, analysis_result)
            # 为类方法测试添加类前缀
            for test_case in method_test_cases:
                test_case.name=f"test_{class_name}_{method_name}" +
                    test_case.name[len(f"test_{method_name}"):]
            _=test_cases.extend(method_test_cases)

        return test_cases

    def generate_test_code(self, test_case: TestCase) -> str:
        """生成测试代码"""
        try:
            # 生成基本的pytest测试代码模板
            test_code=f"""
def {test_case.name}() -> None:
    \"\"\"{test_case.description}\"\"\"
    # 测试 {test_case.function_name} 函数
    # 参数: {', '.join([p.name for p in test_case.parameters])}
    # 预期行为: {test_case.expected_behavior}

    # Arrange
    # Set up test data and preconditions

    # Act
    # Call the function under test

    # Assert
    # Verify the expected behavior
    assert True  # Replace with actual assertions
            return test_code.strip():
""
            return test_code.strip()
        except Exception as e:
            logger.error(
                f"Failed to generate test code for {test_case.name}: {e}")
            return f"# Failed to generate test code for {test_case.name}"

    def get_generated_tests(
        self, limit: Optional[int] = None) -> List[TestCase]:
        """获取生成的测试用例"""
        if limit:
            return self.generated_tests[-limit:]
        return self.generated_tests

    def save_generated_tests(self, output_file: str) -> bool:
        """保存生成的测试用例到文件"""
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                _ = f.write("# Auto-generated test cases\n\n")
                
                for test_case in self.generated_tests:
                    _ = f.write(f"# {test_case.name}\n")
                    _ = f.write(f"# Description: {test_case.description}\n")
                    _ = f.write(f"# Type: {test_case.test_type.value}\n")
                    _ = f.write(f"# Function: {test_case.function_name}\n")
                    _ = f.write(f"# Priority: {test_case.priority}\n")
                    _ = f.write(f"{self.generate_test_code(test_case)}\n\n")
                    
            _ = logger.info(f"Saved {len(self.generated_tests)} test cases to {output_file}")
            return True
        except Exception as e:
            _ = logger.error(f"Failed to save test cases to {output_file}: {e}")
            return False


# 使用示例
if __name__ == "__main__":
    # 创建测试生成器
    generator = IntelligentTestGenerator()
    
    # 为指定文件生成测试用例
    # test_cases = generator.generate_tests_for_file("example_module.py")
    
    # 保存生成的测试用例
    # generator.save_generated_tests("generated_tests.py")
    
    _ = print("Intelligent test generator initialized")
