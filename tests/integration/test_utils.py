"""
集成测试工具模块
提供测试中常用的工具函数和辅助类
"""

import asyncio
import time
from unittest.mock import Mock


class TestTimer:
    """测试计时器"""
    
    def __init__(self) -> None:
        self.start_time = None
        self.end_time = None
    
    def start(self):
        """开始计时"""
        self.start_time = time.time()
    
    def stop(self):
        """停止计时"""
        self.end_time = time.time()
    
    @property
    def elapsed(self) -> float:
        """获取经过的时间"""
        if self.start_time is None:
            return 0.0
        if self.end_time is None:
            return time.time() - self.start_time
        return self.end_time - self.start_time


# 添加pytest标记，防止被误认为测试类
TestTimer.__test__ = False


class AsyncTestHelper:
    """异步测试助手"""
    
    @staticmethod
    async def wait_for_value(getter_func: Callable, expected_value: Any, 
                           timeout: float = 10.0, interval: float = 0.1) -> bool:
        """
        等待某个值达到期望值
        
        Args:
            getter_func: 获取当前值的函数
            expected_value: 期望值
            timeout: 超时时间
            interval: 检查间隔
            
        Returns:
            bool: 是否在超时前达到期望值
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                current_value = getter_func()
                if current_value == expected_value:
                    return True
            except Exception:
                pass
            _ = await asyncio.sleep(interval)
        return False
    
    @staticmethod
    async def wait_for_condition(condition_func: Callable, 
                               timeout: float = 10.0, interval: float = 0.1) -> bool:
        """
        等待条件满足
        
        Args:
            condition_func: 条件检查函数
            timeout: 超时时间
            interval: 检查间隔
            
        Returns:
            bool: 条件是否满足
        """
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                if condition_func():
                    return True
            except Exception:
                pass
            _ = await asyncio.sleep(interval)
        return False


class MockServiceManager:
    """Mock服务管理器"""
    
    def __init__(self) -> None:
        self.mocks = {}
        self.calls = {}
    
    def create_mock(self, name: str, spec=None) -> Mock:
        """
        创建mock服务
        
        Args:
            name: 服务名称
            spec: 规范对象
            
        Returns:
            Mock: mock对象
        """
        mock = Mock(spec=spec)
        self.mocks[name] = mock
        self.calls[name] = []
        return mock
    
    def get_mock(self, name: str) -> Mock:
        """
        获取mock服务
        
        Args:
            name: 服务名称
            
        Returns:
            Mock: mock对象
        """
        return self.mocks.get(name)
    
    def record_call(self, service_name: str, method_name: str, args: tuple, kwargs: dict):
        """
        记录方法调用
        
        Args:
            service_name: 服务名称
            method_name: 方法名称
            args: 位置参数
            kwargs: 关键字参数
        """
        if service_name in self.calls:
            self.calls[service_name].append({
                "method": method_name,
                "args": args,
                "kwargs": kwargs,
                "timestamp": time.time()
            })
    
    def get_calls(self, service_name: str) -> List[Dict]:
        """
        获取服务调用记录
        
        Args:
            service_name: 服务名称
            
        Returns:
            List[Dict]: 调用记录列表
        """
        return self.calls.get(service_name, [])
    
    def reset_calls(self, service_name: str = None):
        """
        重置调用记录
        
        Args:
            service_name: 服务名称，如果为None则重置所有
        """
        if service_name:
            if service_name in self.calls:
                self.calls[service_name] = []
        else:
            for service_calls in self.calls.values():
                service_calls = []


# 添加pytest标记，防止被误认为测试类
MockServiceManager.__test__ = False


class TestMetricsCollector:
    """测试指标收集器"""
    
    def __init__(self) -> None:
        self.metrics = {}
    
    def record_metric(self, name: str, value: Any, tags: Dict[str, str] = None):
        """
        记录指标
        
        Args:
            name: 指标名称
            value: 指标值
            tags: 标签
        """
        if name not in self.metrics:
            self.metrics[name] = []
        
        metric_data = {
            "value": value,
            "timestamp": time.time(),
            "tags": tags or {}
        }
        self.metrics[name].append(metric_data)
    
    def get_metrics(self, name: str) -> List[Dict]:
        """
        获取指标数据
        
        Args:
            name: 指标名称
            
        Returns:
            List[Dict]: 指标数据列表
        """
        return self.metrics.get(name, [])
    
    def get_average(self, name: str) -> float:
        """
        获取指标平均值
        
        Args:
            name: 指标名称
            
        Returns:
            float: 平均值
        """
        metrics = self.get_metrics(name)
        if not metrics:
            return 0.0
        return sum(m["value"] for m in metrics) / len(metrics)


# 添加pytest标记，防止被误认为测试类
TestMetricsCollector.__test__ = False


class TestEnvironmentManager:
    """测试环境管理器"""
    
    def __init__(self) -> None:
        self.original_env = {}
        self.temp_env = {}
    
    def set_temp_env(self, key: str, value: str):
        """
        设置临时环境变量
        
        Args:
            key: 环境变量名
            value: 环境变量值
        """
        import os
        self.original_env[key] = os.environ.get(key)
        self.temp_env[key] = value
        os.environ[key] = value
    
    def restore_env(self):
        """恢复环境变量"""
        import os
        for key, value in self.original_env.items():
            if value is None:
                os.environ.pop(key, None)
            else:
                os.environ[key] = value
        self.original_env.clear()
        self.temp_env.clear()


# 添加pytest标记，防止被误认为测试类
TestEnvironmentManager.__test__ = False


def create_test_data(data_type: str, count: int = 5) -> List[Dict]:
    """
    创建测试数据
    
    Args:
        data_type: 数据类型
        count: 数据数量
        
    Returns:
        List[Dict]: 测试数据列表
    """
    if data_type == "text":
        return [
            {
                "id": f"text_{i}",
                "content": f"Test text content {i}",
                "metadata": {"type": "text", "source": "test"}
            }
            for i in range(count)
        ]
    elif data_type == "image":
        return [
            {
                "id": f"image_{i}",
                "path": f"/test/images/image_{i}.jpg",
                "metadata": {"type": "image", "source": "test"}
            }
            for i in range(count)
        ]
    else:
        return [
            {
                "id": f"data_{i}",
                "value": f"test_value_{i}",
                "metadata": {"type": data_type, "source": "test"}
            }
            for i in range(count)
        ]


def assert_dict_contains(actual: Dict, expected: Dict):
    """
    断言字典包含期望的键值对
    
    Args:
        actual: 实际字典
        expected: 期望字典
    """
    for key, value in expected.items():
        assert key in actual, f"Key '{key}' not found in actual dict"
        assert actual[key] == value, f"Value mismatch for key '{key}': expected {value}, got {actual[key]}"


def wait_for_async_condition(condition_func, timeout=10.0, interval=0.1):
    """
    等待异步条件满足
    
    Args:
        condition_func: 条件函数
        timeout: 超时时间
        interval: 检查间隔
        
    Returns:
        bool: 条件是否满足
    """
    import asyncio
    loop = asyncio.get_event_loop()
    
    async def _wait():
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                if condition_func():
                    return True
            except Exception:
                pass
            _ = await asyncio.sleep(interval)
        return False
    
    return loop.run_until_complete(_wait())