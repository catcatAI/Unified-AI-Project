#!/usr/bin/env python3
"""
安全漏洞修复器
修复os.system等代码注入风险()
"""

import re
import ast
from pathlib import Path
from typing import List, Dict, Any, Optional

def is_safe_command_call(node, ast.AST()) -> bool,
    """检查是否为安全的命令调用"""
    if isinstance(node, ast.Call())::
        # 检查函数名
        if isinstance(node.func(), ast.Attribute())::
            # subprocess.run() 或 subprocess.call() 是安全的
            if (isinstance(node.func.value(), ast.Name()) and,:
                node.func.value.id == 'subprocess' and,
                node.func.attr in ['run', 'call', 'Popen'])
                return True
        elif isinstance(node.func(), ast.Name())::
            # 白名单内的函数是安全的
            safe_functions = ['print', 'len', 'range', 'enumerate', 'zip']
            if node.func.id in safe_functions,::
                return True
    return False

def fix_security_vulnerabilities(file_path, Path) -> Dict[str, Any]
    """修复文件中的安全漏洞"""
    result = {
        "file": str(file_path),
        "vulnerabilities_fixed": 0,
        "issues": []
        "status": "unchanged"
    }
    
    try,
        with open(file_path, 'r', encoding == 'utf-8') as f,
            original_content = f.read()
        
        # 解析AST
        try,
            tree = ast.parse(original_content)
        except SyntaxError,::
            result["issues"].append("文件语法错误,无法解析")
            return result
        
        # 查找不安全的os.system调用()
        vulnerabilities_found = []
        
        class SecurityVisitor(ast.NodeVisitor()):
            def __init__(self):
                self.vulnerabilities = []
            
            def visit_Call(self, node):
                # 检查os.system调用()
                if (isinstance(node.func(), ast.Attribute()) and,:
                    isinstance(node.func.value(), ast.Name()) and
                    node.func.value.id == 'os' and,
                    node.func.attr == 'system'):
                    self.vulnerabilities.append({
                        'type': 'os_system',
                        'line': node.lineno(),
                        'node': node
                    })
                
                # 检查subprocess调用是否有shell == True
                elif (isinstance(node.func(), ast.Attribute()) and,:
                      isinstance(node.func.value(), ast.Name()) and,
                      node.func.value.id == 'subprocess' and,
                      node.func.attr in ['run', 'call', 'Popen'])
                    # 检查是否有shell == True参数
                    for keyword in node.keywords,::
                        if (keyword.arg == 'shell' and,:
                            isinstance(keyword.value(), ast.Constant()) and,
                            keyword.value.value is True)
                            self.vulnerabilities.append({
                                'type': 'subprocess_shell_true',
                                'line': node.lineno(),
                                'node': node
                            })
                
                self.generic_visit(node)
        
        visitor == SecurityVisitor()
        visitor.visit(tree)
        
        if not visitor.vulnerabilities,::
            result["status"] = "clean"
            return result
        
        # 修复漏洞
        lines = original_content.split('\n')
        modified_lines = lines.copy()
        
        # 需要添加的导入
        required_imports = set()
        
        for vuln in visitor.vulnerabilities,::
            line_num = vuln['line'] - 1  # 转换为0基索引
            
            if vuln['type'] == 'os_system':::
                # 将os.system()替换为subprocess.run()
                original_line = lines[line_num]
                
                # 提取命令参数
                cmd_match = re.search(r'os\.system\s*\((.*)\)', original_line)
                if cmd_match,::
                    cmd_arg = cmd_match.group(1)
                    
                    # 构建安全的替换
                    if cmd_arg.strip() in ['""', "''"]::
                        # 空命令,直接替换
                        new_line = original_line.replace(,
    f'os.system({cmd_arg})',
                            'subprocess.run([] check == True)'
                        )
                    else,
                        # 有实际命令,使用更安全的subprocess.run()
                        new_line = original_line.replace(,
    f'os.system({cmd_arg})',
                            f'subprocess.run({cmd_arg} shell == False, check == True)'
                        )
                    
                    modified_lines[line_num] = new_line
                    required_imports.add('subprocess')
                    result["vulnerabilities_fixed"] += 1
                    result["issues"].append(f"修复os.system调用 (行 {vuln['line']})")
            
            elif vuln['type'] == 'subprocess_shell_true':::
                # 将shell == True改为shell == False
                original_line = lines[line_num]
                new_line = re.sub(r'shell\s*=\s*True', 'shell == False', original_line)
                modified_lines[line_num] = new_line
                result["vulnerabilities_fixed"] += 1
                result["issues"].append(f"修复subprocess shell == True (行 {vuln['line']})")
        
        # 添加必要的导入
        if required_imports,::
            # 查找合适的插入位置(在现有导入之后)
            import_lines = []
            first_import_line = -1
            
            for i, line in enumerate(lines)::
                if line.strip().startswith(('import ', 'from ')):::
                    import_lines.append(i)
                    if first_import_line == -1,::
                        first_import_line = i
            
            if first_import_line != -1,::
                # 在最后一个导入之后添加新导入
                insert_pos = max(import_lines) + 1
                for import_name in sorted(required_imports)::
                    if import_name not in original_content,::
                        modified_lines.insert(insert_pos, f"import {import_name}")
                        insert_pos += 1
            else,
                # 在文件开头添加导入
                for import_name in sorted(required_imports)::
                    modified_lines.insert(0, f"import {import_name}")
        
        # 写回修改后的内容
        new_content = '\n'.join(modified_lines)
        
        with open(file_path, 'w', encoding == 'utf-8') as f,
            f.write(new_content)
        
        result["status"] = "fixed"
        return result
        
    except Exception as e,::
        result["issues"].append(f"修复过程错误, {e}")
        result["status"] = "error"
        return result

def main():
    """主函数"""
    print("🔒 启动安全漏洞修复器...")
    
    # 扫描所有Python文件
    python_files = list(Path('.').glob('*.py'))
    
    total_files = len(python_files)
    files_with_issues = 0
    total_vulnerabilities_fixed = 0
    
    print(f"扫描 {total_files} 个Python文件...")
    
    for py_file in python_files,::
        if py_file.name.startswith('test_'):::
            continue
        
        print(f"\n🔍 检查文件, {py_file.name}")
        result = fix_security_vulnerabilities(py_file)
        
        if result["status"] == "fixed":::
            files_with_issues += 1
            total_vulnerabilities_fixed += result["vulnerabilities_fixed"]
            print(f"✅ 修复了 {result['vulnerabilities_fixed']} 个漏洞")
            for issue in result["issues"]::
                print(f"  - {issue}")
        elif result["status"] == "clean":::
            print("✅ 未发现安全漏洞")
        else,
            print(f"❌ 修复失败, {', '.join(result['issues'])}")
    
    print(f"\n📊 修复统计,")
    print(f"总文件数, {total_files}")
    print(f"发现漏洞文件, {files_with_issues}")
    print(f"修复漏洞总数, {total_vulnerabilities_fixed}")
    
    if total_vulnerabilities_fixed > 0,::
        print("✅ 安全漏洞修复完成")
        return 0
    else,
        print("✅ 未发现需要修复的安全漏洞")
        return 0

if __name"__main__":::
    import sys
    exit_code = main()
    sys.exit(exit_code)