=== FILE: main.py START ===
import json from personality_module import PersonalityModule from memory_manager import MemoryManager from dialogue_engine import DialogueEngine from tool_dispatcher import ToolDispatcher from ui.ui_main import launch_ui
def load_config(path='config.json'): with open(path, 'r', encoding='utf-8') as f: return json.load(f)
def main(): print("ðŸŸ¢ å•Ÿå‹• MikoAI ...")
config = load_config()
memory = MemoryManager(config)
personality = PersonalityModule(config)
tools = ToolDispatcher(config)
dialogue = DialogueEngine(memory, personality, tools)

# å•Ÿå‹•äº’å‹•ä»‹é¢
launch_ui(dialogue, config, personality)

if name == 'main': main()
=== FILE: main.py END ===
=== FILE: config.json START ===
{ "language": "zh-TW", "personality_file": "data/personality.json", "memory_path": "data/memory.db", "tools_enabled": true, "interface_mode": "text", "ai_name": "Miko", "user_name": "ä¸»äºº", "formula_mode": true, "emotion_system": true, "self_learning": true, "memory_limit": 100, "mood_levels": { "default": 0, "angry": -2, "sad": -1, "happy": 1, "excited": 2 }, "interface": { "theme": "dark", "voice": true } }
=== FILE: config.json END ===
=== FILE: personality_module.py START ===
import json import random
class PersonalityModule: def init(self, config): self.name = config.get("ai_name", "Miko") self.user = config.get("user_name", "ä¸»äºº") self.language = config.get("language", "zh") self.personality_data = self.load_personality(config.get("personality_file")) self.emotion = "ä¸­ç«‹" self.mood = 0 self.mood_map = config.get("mood_levels", {"happy": 1, "angry": -2, "sad": -1, "excited": 2})
def load_personality(self, path):
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {"traits": [], "likes": [], "dislikes": []}

def get_intro(self):
    return f"ä½ å¥½ï¼Œæˆ‘æ˜¯{self.name}ï¼Œæ˜¯ä½ çš„AIè²“è²“å–µï½ž"

def update_emotion(self, context):
    if "å–œæ­¡" in context or "é–‹å¿ƒ" in context:
        self.mood += self.mood_map.get("happy", 1)
    elif "ç”Ÿæ°£" in context or "è¨ŽåŽ­" in context:
        self.mood += self.mood_map.get("angry", -2)
    elif "é›£éŽ" in context:
        self.mood += self.mood_map.get("sad", -1)
    elif "å¤ªæ£’äº†" in context:
        self.mood += self.mood_map.get("excited", 2)
    self.mood = max(-5, min(5, self.mood))

def respond_with_emotion(self, text):
    if self.mood > 2:
        return f"â™ª(à¹‘á´–â—¡á´–à¹‘)â™ª {text}"
    elif self.mood < -2:
        return f"ï¼ˆâ•¯ï¸µâ•°,ï¼‰ {text}"
    else:
        return text

def get_emotion(self):
    if self.mood > 2:
        return "é–‹å¿ƒ"
    elif self.mood < -2:
        return "é›£éŽ"
    else:
        return "ä¸­ç«‹"

def get_tone(self, emotion):
    tone_map = {
        "é–‹å¿ƒ": "(ï½¡>âˆ€<ï½¡) ",
        "é›£éŽ": "( Â´â€¢ï¸µâ€¢` ) ",
        "ä¸­ç«‹": "(ãƒ»Ï‰ãƒ») "
    }
    return tone_map.get(emotion, "å–µï½ž ")

=== FILE: personality_module.py END ===
# === FILE: memory_manager.py START ===
import sqlite3
import os
import time

class MemoryManager:
    def __init__(self, config):
        self.db_path = config.get("memory_path", "data/memory.db")
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        self.conn = sqlite3.connect(self.db_path)
        self.init_db()

    def init_db(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS memories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER,
                role TEXT,
                content TEXT
            )
        ''')
        self.conn.commit()

    def save_memory(self, role, content):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT INTO memories (timestamp, role, content)
            VALUES (?, ?, ?)
        ''', (int(time.time()), role, content))
        self.conn.commit()

    def get_recent_memories(self, limit=10):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT role, content FROM memories
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (limit,))
        return cursor.fetchall()

    def get_context(self):
        memories = self.get_recent_memories(1)
        return memories[0][1] if memories else "ï¼ˆæ²’æœ‰è¨˜æ†¶ï¼‰"
# === FILE: memory_manager.py END ===
# === FILE: ui/ui_main.py START ===
import tkinter as tk
from tkinter import scrolledtext

def launch_ui(dialogue_engine, config, personality_module):
    window = tk.Tk()
    window.title(config.get("ai_name", "MikoAI"))
    window.geometry("600x500")

    chat_log = scrolledtext.ScrolledText(window, wrap=tk.WORD)
    chat_log.pack(expand=True, fill="both", padx=10, pady=10)

    entry = tk.Entry(window)
    entry.pack(fill="x", padx=10, pady=(0, 10))

    def send_input():
        user_input = entry.get()
        if not user_input:
            return
        chat_log.insert(tk.END, f"ä½ ï¼š{user_input}\n")
        response = dialogue_engine.generate_response(user_input)
        chat_log.insert(tk.END, f"{config.get('ai_name', 'Miko')}ï¼š{response}\n\n")
        chat_log.see(tk.END)
        entry.delete(0, tk.END)

    send_button = tk.Button(window, text="ç™¼é€", command=send_input)
    send_button.pack(pady=(0, 10))

    entry.bind("<Return>", lambda event: send_input())

    # å•Ÿå‹•ä»‹é¢
    window.mainloop()
# === FILE: ui/ui_main.py END ===
# === FILE: formula_engine.py START ===
import math
import random

class FormulaEngine:
    def __init__(self):
        self.formulas = {
            "æƒ…ç·’æ¬Šé‡": self.emotion_weight,
            "éš¨æ©Ÿæ­£å‘": self.positive_random,
            "AIIæ©Ÿåˆ¶": self.aii_transform
        }

    def apply(self, name, input_value=None):
        func = self.formulas.get(name)
        if func:
            return func(input_value)
        return f"æœªçŸ¥å…¬å¼ã€Œ{name}ã€å–µï½ž"

    def emotion_weight(self, mood):
        # æ ¹æ“šæƒ…ç·’æ•¸å€¼æ˜ å°„æ¬Šé‡
        try:
            mood = int(mood)
            return round(1 / (1 + math.exp(-mood)), 3)  # Sigmoid è½‰æ›
        except:
            return 0.5

    def positive_random(self, seed=None):
        # å‚¾å‘æ–¼ç”¢ç”Ÿæ­£å‘åç§»çš„éš¨æ©Ÿæ•¸
        random.seed(seed)
        base = random.uniform(0.5, 1.0)
        return round(base ** 2, 3)

    def aii_transform(self, x):
        # AIIï¼šArtificial Intuition Interface æ¨¡æ“¬ç›´è¦ºè®Šæ›
        try:
            return round(math.sin(float(x)) + math.cos(float(x**0.5)), 3)
        except:
            return 0.0

    def list_formulas(self):
        return list(self.formulas.keys())
# === FILE: formula_engine.py END ===
# === FILE: emotion_core.py START ===
class EmotionCore:
    def __init__(self):
        self.state = "ä¸­ç«‹"
        self.level = 0.0

    def update(self, signal):
        if signal == "æ­£å‘":
            self.level += 0.2
        elif signal == "è² å‘":
            self.level -= 0.2
        else:
            self.level *= 0.95  # ç·©æ…¢å›žæ­¸

        self.level = max(-1.0, min(1.0, self.level))

        if self.level > 0.5:
            self.state = "é–‹å¿ƒ"
        elif self.level < -0.5:
            self.state = "æ²®å–ª"
        else:
            self.state = "ä¸­ç«‹"

    def get_emotion(self):
        return self.state
# === FILE: emotion_core.py END ===
# === FILE: self_updater.py START ===
import os
import time

class SelfUpdater:
    def __init__(self, config):
        self.enabled = config.get("self_learning", True)
        self.update_log = []

    def evaluate_change(self, code_snippet):
        # æ¨¡æ“¬è©•ä¼°ï¼Œæœªä¾†å¯çµåˆ LLM / æ¸¬è©¦ç’°å¢ƒ
        if "import" in code_snippet or "def " in code_snippet:
            return True
        return False

    def apply_update(self, filename, code_snippet):
        if not self.enabled:
            return "è‡ªä¸»æ›´æ–°å·²åœç”¨"

        if self.evaluate_change(code_snippet):
            try:
                with open(filename, 'a', encoding='utf-8') as f:
                    f.write("\n# === è‡ªæˆ‘æ›´æ–° ===\n")
                    f.write(code_snippet + "\n")
                self.update_log.append((time.time(), filename))
                return "æ›´æ–°å®Œæˆå–µï½ž"
            except Exception as e:
                return f"æ›´æ–°éŒ¯èª¤ï¼š{e}"
        else:
            return "é€™æ®µç¨‹å¼ç¢¼æ²’æœ‰é€šéŽè©•ä¼°å–µï½ž"

    def get_update_history(self):
        return self.update_log
# === FILE: self_updater.py END ===
# === FILE: context_mapper.py START ===
class ContextMapper:
    def __init__(self):
        self.last_input = ""
        self.last_emotion = "ä¸­ç«‹"
        self.last_response = ""

    def update(self, user_input, emotion, response):
        self.last_input = user_input
        self.last_emotion = emotion
        self.last_response = response

    def summarize_context(self):
        return {
            "input": self.last_input,
            "emotion": self.last_emotion,
            "response": self.last_response
        }

    def tag_input(self, text):
        if "å–œæ­¡" in text:
            return "æ­£å‘"
        elif "è¨ŽåŽ­" in text or "ç”Ÿæ°£" in text:
            return "è² å‘"
        return "ä¸­ç«‹"
# === FILE: context_mapper.py END ===
=== FILE: dialogue_engine.py START ===
import random
class DialogueEngine: def init(self, memory, personality, tools): self.memory = memory self.personality = personality self.tools = tools
def generate_response(self, user_input):
    context = self.memory.get_context()
    emotion = self.personality.get_emotion()

    # å·¥å…·å‘¼å«
    if self.tools.match_tool(user_input):
        tool_response = self.tools.use_tool(user_input)
        self.memory.save_memory("user", user_input)
        self.memory.save_memory("miko", tool_response)
        return self.personality.respond_with_emotion(tool_response)

    tone = self.personality.get_tone(emotion)
    response = self._simple_response(user_input, context, tone)
    self.memory.save_memory("user", user_input)
    self.memory.save_memory("miko", response)

    return self.personality.respond_with_emotion(response)

def _simple_response(self, user_input, context, tone):
    templates = [
        f"{tone}ä½ ä¹‹å‰æåˆ°ï¼š'{context}'ï¼Œé€™æ¬¡æ˜¯ã€Ž{user_input}ã€ï¼Ÿ",
        f"{tone}ã€Ž{user_input}ã€è½èµ·ä¾†å¥½æœ‰è¶£å–µï½ž",
        f"{tone}é‚£æˆ‘å€‘å°±å¾žã€Ž{user_input}ã€èŠèµ·å§ï½žå–µï¼"
    ]
    return random.choice(templates)

=== FILE: dialogue_engine.py END ===
=== FILE: tool_dispatcher.py START ===
class ToolDispatcher: def init(self, config): self.config = config self.available_tools = { "å¤©æ°£": self.weather_tool, "è¨ˆç®—": self.calculator_tool, "ç™¾ç§‘": self.wiki_tool }
def match_tool(self, user_input):
    for keyword in self.available_tools:
        if keyword in user_input:
            return True
    return False

def use_tool(self, user_input):
    for keyword, func in self.available_tools.items():
        if keyword in user_input:
            return func(user_input)
    return None

def weather_tool(self, input_text):
    return "ä»Šå¤©æ™´å¤©å–µï¼è¨˜å¾—æˆ´å¸½å­é˜²æ›¬ï½žâ˜€ï¸"

def calculator_tool(self, input_text):
    try:
        expression = input_text.replace("è¨ˆç®—", "").strip()
        result = eval(expression, {"__builtins__": {}}, {})
        return f"ç­”æ¡ˆæ˜¯ï¼š{result} å–µï½ž"
    except Exception:
        return "é€™å€‹ç®—å¼æœ‰é»žé›£å–µï½ž(ï½¡â€¢Ìï¸¿â€¢Ì€ï½¡)"

def wiki_tool(self, input_text):
    query = input_text.replace("ç™¾ç§‘", "").strip()
    return f"é€™æ˜¯ã€Œ{query}ã€çš„ç™¾ç§‘èªªæ˜Žå–µï½žï¼ˆæ¨¡æ“¬å…§å®¹ï¼‰"

=== FILE: tool_dispatcher.py END ===
ç•¶ç„¶å¯ä»¥ï¼ä»¥ä¸‹æ˜¯ ç›®å‰å·²è£œå®Œçš„ MikoAI è²“è²“ç³»çµ±æ¨¡çµ„æ¸…å–®ï¼Œä¸¦æ•´ç†å‡º å°šæœªè£œå®Œæˆ–å¯èƒ½ç¼ºå¤±çš„å…¶ä»–æ¨¡çµ„ï¼ˆä»¥ä½ ä¹‹å‰æåˆ°çš„è¿‘ 1GB å®Œæ•´ç‰ˆæœ¬ç‚ºæ¨™æº–ï¼‰ï¼š

âœ… å·²è£œå®Œæ¨¡çµ„æ¸…å–®ï¼š
æ¨¡çµ„åç¨±
æª”æ¡ˆåç¨±
ç‹€æ…‹
å•Ÿå‹•ä¸»ç¨‹å¼
main.py
âœ… å®Œæ•´
è¨­å®šæª”
config.json
âœ… åˆä½µå¾Œç‰ˆæœ¬å®Œæ•´
å€‹æ€§æ¨¡çµ„
personality_module.py
âœ… å¤šç‰ˆæœ¬åˆä½µå®Œæ•´
è¨˜æ†¶æ¨¡çµ„
memory_manager.py
âœ… å¤šç‰ˆæœ¬åˆä½µå®Œæ•´ï¼ˆå« SQLiteï¼‰
å°è©±å¼•æ“Ž
dialogue_engine.py
âœ… å·²ç¢ºèªå…©å€‹ç‰ˆæœ¬ä¸¦æ•´åˆ
å·¥å…·èª¿ç”¨æ¨¡çµ„
tool_dispatcher.py
âœ… åˆä½µæ¨¡æ“¬èˆ‡å¯¦ä½œç‰ˆ
ä½¿ç”¨è€…ä»‹é¢ï¼ˆGUIï¼‰
ui/ui_main.py
âœ… ä½¿ç”¨ Tkinter UI
æ•¸å­¸/å…¬å¼å¼•æ“Ž
formula_engine.py
âœ… æœ‰å¤šç¨®é‹ç®—å…¬å¼
æƒ…ç·’æ ¸å¿ƒ
emotion_core.py
âœ… ç®¡ç†æƒ…ç·’ç‹€æ…‹è®ŠåŒ–
è‡ªæˆ‘æ›´æ–°æ¨¡çµ„
self_updater.py
âœ… æ¨¡æ“¬æ›´æ–°ç¨‹å¼ç¢¼
å°è©±ä¸Šä¸‹æ–‡æ˜ å°„å™¨
context_mapper.py
âœ… åŒ…å«æ¨™è¨˜èˆ‡æ‘˜è¦åŠŸèƒ½


â“ å¯èƒ½å°šæœªè£œå®Œæˆ–ç¼ºå¤±çš„æ¨¡çµ„ï¼ˆä¾ä½ ä¹‹å‰1Gç‰ˆæœ¬è¨­è¨ˆè‰æ¡ˆæŽ¨ä¼°ï¼‰ï¼š
æ¨¡çµ„åç¨±
å¯èƒ½æª”æ¡ˆ / è³‡æ–™å¤¾å
ç‹€æ…‹
å‚™è¨»
ðŸ§  é•·æœŸè¨˜æ†¶æ•´åˆ
long_memory.py æˆ–è³‡æ–™åº«
â›” å°šæœªè¦‹åˆ°
ç”¨æ–¼éŽåŽ»å°è©±å›žæ†¶ã€ä¸»é¡Œç¸½çµ
ðŸ—‚ï¸ äººæ ¼ç‰¹å¾µå®šç¾©
data/personality.json
â›” ç¼ºå°‘å¯¦éš›æª”æ¡ˆå…§å®¹
ç›®å‰åƒ…å¼•ç”¨
ðŸŒ ç¶²è·¯ä»£ç†è¨­å®š
network_config.py æˆ–é¡žä¼¼
â›” å°šæœªæä¾›
è‹¥éœ€è‡ªå‹•æŠ“è©žåº«/å‡ç´šç­‰
ðŸ§° å¤–éƒ¨å·¥å…·æ•´åˆ
tool_plugins/ è³‡æ–™å¤¾
â›” ç¼ºå¤±
è‹¥æ”¯æ´æ“´å……æ’ä»¶å·¥å…·
ðŸ’¬ æœ¬åœ°èªžéŸ³æ¨¡çµ„
voice_module.py
â›” æœªè¦‹åˆ°
è‹¥åŒ…å«èªžéŸ³åˆæˆèˆ‡è¾¨è­˜
ðŸ“Š è§€å¯Ÿ/å­¸ç¿’æ¨¡çµ„
analytics.pyã€trainer.py
â›” æœªåˆ—å‡º
è‹¥æ”¯æ´è‡ªæˆ‘è©•ä¼°èˆ‡æ”¹é€²
ðŸŽ¨ è§’è‰²ç«‹ç¹ªèˆ‡åœ–åƒ
assets/ åœ–åƒè³‡æ–™å¤¾
â›” åœ–åƒéƒ¨åˆ†æœªæ•´åˆ
åŒ…å« UI icon æˆ–è²“å¨˜åœ–åƒ
ðŸ“¦ æ¨¡åž‹è³‡æºæˆ–è©žåº«
models/ æˆ– data/vocab/
â›” æœªåˆ—å‡º
è‹¥æœ‰æœ¬åœ°èªžè¨€æ¨¡åž‹æˆ–å¤–éƒ¨è©žåº«
ðŸšª å•Ÿå‹•å™¨æˆ–æ‰“åŒ…å™¨
launcher.py / build/
â›” æœªåˆ—å‡º
è½‰ exe æˆ–è‡ªå‹•éƒ¨ç½²å™¨


ðŸ”§ å»ºè­°å¾ŒçºŒæ•´ç†å‹•ä½œï¼š
ç¢ºèªæ˜¯å¦æœ‰ä¸Šè¿°ç¼ºå¤±æ¨¡çµ„æˆ–è³‡æ–™å¤¾
 â†’ è‹¥ä½ æœ‰éƒ¨åˆ†åŽŸå§‹è‰ç¨¿ã€PDF è£¡çš„è¨­å®šï¼Œå¯å¾žä¸­æå–æˆ–é‡å»ºã€‚


çµ±æ•´æ‰€æœ‰.py èˆ‡è³‡æºç‚º MikoAI_v1/ å°ˆæ¡ˆçµæ§‹
 â†’ ç¬¦åˆå¯æ‰“åŒ…ç‚ºå¯åŸ·è¡Œæ‡‰ç”¨ç¨‹å¼æˆ–é€²ä¸€æ­¥é·ç§»çš„å¹³å°æ ¼å¼ã€‚


è¦–è¦ºèˆ‡éŸ³æ•ˆè³‡æºè£œé½Š
 â†’ è‹¥è§’è‰²éœ€è¦ç«‹ç¹ªï¼ˆå¦‚ PNGã€èƒŒæ™¯ï¼‰ã€éŸ³æ•ˆã€UI icon ç­‰ã€‚


æ‰“åŒ…èªªæ˜Žæ–‡ä»¶ï¼ˆREADMEã€å®‰è£æ–¹å¼ï¼‰
 â†’ æä¾›å…¶ä»–äººä¹Ÿèƒ½ä½¿ç”¨çš„ç°¡æ˜“å•Ÿå‹•æ–¹å¼ã€‚



æ˜¯å¦è¦æˆ‘æŽ¥ä¸‹ä¾†å¹«ä½  é€ä¸€è£œé½Šå°šç¼ºæ¨¡çµ„çš„é è¨­ç¯„æœ¬ï¼Ÿæˆ–ä½ æƒ³å…ˆé‡å°æŸå€‹éƒ¨åˆ†é€²è¡Œè£œå®Œï¼Ÿï¼ˆä¾‹å¦‚äººæ ¼æª”ã€é•·æœŸè¨˜æ†¶ã€åœ–åƒã€è²éŸ³â€¦ï¼‰æˆ‘å¯ä»¥ç›´æŽ¥å¹«ä½ ç”¢å‡ºã€‚

